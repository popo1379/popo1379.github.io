[{"title":"用分配蛋糕的方法显浅理解区块链pow共识机制","date":"2018-02-04T07:22:13.000Z","path":"2018/02/04/2018-2-4/","text":"区块链的共识机制是为了解决区块由谁构造构造及如何维护的问题而产生的一直特殊算法，其理论基础源于拜占庭容错，共识机制的核心是区块的构造和检验，目前业内有POW，POS，DPOS三种形式的共识机制理论。 共识机制的目的，是为了防范无利益信息对区块链的危害，在这里，我用分配蛋糕的方式，来抽象共识机制。 相传在古代的一个岛上，有一群居民（矿场），由于物资极其匮乏，因此在岛上，蛋糕（区块）是一种极度稀缺的美味食品，岛上居民向上帝乞求赐予居民蛋糕，终于有一天上帝回应了他们，向小岛上赐予了一块蛋糕。 蛋糕对小道上的所有居民都是可见的（区块链的开放性使所有人都可以加入），可是蛋糕只有一块，那么该由谁来享用呢？要避免居民去无秩序的争抢蛋糕引发事故，还要防止有不喜欢吃蛋糕的人去破坏蛋糕，必须采用一种机制去保证蛋糕公平公正的给予真正需要蛋糕的人，因此，上帝采用了一种机制解决问题，这就是POW（proof of work）即工作量证明机制，上帝让居民进行赛跑（算力竞争），最先达到终点的人即可拥有蛋糕的所属权。 居民们为了吃到蛋糕，于是进行了激烈的竞争，最终，一位身强力壮善于赛跑的年轻人（算力高）先达到了终点，于是他获得了蛋糕的所属权（构造区块链）。 年轻人由于消耗了大量的体力（消耗能源），因此需要蛋糕来补充体力，此时年轻人便有了保护蛋糕不被破坏的动机（维护区块安全）。 尽管POW法解决了蛋糕的问配问题，但却也有几个缺点： 1：无意义的能量消耗 2 ：蛋糕依然是被上帝赐予的，居民们没有办法制造蛋糕。（价值需要依靠外部输出）","tags":[{"name":"区块链","slug":"区块链","permalink":"https://popo1379.github.io/tags/区块链/"}]},{"title":"观影《银翼杀手2049》：科幻反乌托邦下的「人性」思考","date":"2018-01-31T06:55:14.000Z","path":"2018/01/31/2018-1-31/","text":"“机器人会梦见电子羊吗？” 对于《银翼杀手》电影，在2049上映前我一直是耳闻其名却从未观影过，作为科幻电影史上的里程碑，银翼杀手为后世的科幻电影提供了大量的素材，在后世的《黑客帝国》系列和《攻壳机动队》等末世科幻经典作品中出现的“克隆人”和人格化AI都可以追溯本源到银翼杀手中。这次的《银翼杀手2049》作为导演Denis Villeneuve的经典致敬作，沿用了前作的世界观和人物关系，向世人讲述了原作30年后的翼杀手故事。 故事讲述了在地球大停电时期后，科学家华莱士通过新型农业技术解决了人类食物短缺问题，并收购了泰勒公司后推出9号复制人，男主角 K 就是一名9号复制人，他作为「银翼杀手」供职于洛杉矶警局，负责清理旧型号复制人。K在清理旧复制人的途中，意外的发现了一个埋藏在树下的密封箱和神秘数字，并由此引出了一个惊人的秘密：被人类视为“产品”的复制人拥有生育能力并生下了孩子藏在这个世界的某个角落中。当局为了维持人类与复制人间的关系，决定派 K 调查并消灭证据，而 K 在调查寻找证据的过程中，逐渐发现自己与那个复制人孩子间的某种关联…… 剧情的焦点在于复制人所生的孩子，这个世界中，复制人与人类几乎完全相同，有着同样的记忆和感情，但复制人是“产品”，是为人类服务的劳动机器，复制人拥有了生育的能力，这无疑冲击了人类文明的伦理观念：复制人的孩子是人类还是“产品”？ 而在复制人的眼中，将其视为“神迹”，复制人拥有了属于自己的后代，必然打破这个世界原有的平衡。 身为复制人的 K 爱上了人工智能 JOI，当得知自己童年那段记忆是真实的时，K的第一个想法是自己就是那个孩子，“所有出生的人类，都拥有灵魂” ，在 K 的内心当中，一直视复制人是没有“灵魂”的生命，当 K 以“人类”的身份拥有了人性，拥有了爱他人的权利的时候，他变得欣喜若狂又不知所措，而之后的反转，当 K 得知了真相后，复制人依旧是复制人，只不过此刻，他终于找到了自己要追求的东西，他要为灵魂而战，为人性而战。 在故事中，复制人被人类视为“产品”，然而这些被人类压抑已久的复制人，却正在被“神迹”唤醒自身的「人性」，那段神秘数字和被植入的童年木马记忆，是解开每个复制人灵魂的钥匙。 K 的虚拟AI女友JOI是电影里我最喜欢的角色，身为人工智能的她在 K 迷茫时，给予了他最大的帮助和鼓励，而在 K 的发散机被踩碎那一刻，JOI说出了“我爱你”，此刻，有多少人将JOI视为真实存在的人？人工智能的情感，到底是真实的情感还是程序操控的情感？。电影的结尾，在白雪中，伴着BGM「Tears in the Rain」，K 望向天空，导演没有交代 K 及所有复制人反抗者的未来，或许反抗军在与人类的战争中获得了胜利，又或许在人类发展进化的历史长河中，复制人的这段故事只是一个小小的插曲，但在对人性的思考，是这个社会发展中永恒的话题。","tags":[{"name":"影评","slug":"影评","permalink":"https://popo1379.github.io/tags/影评/"}]},{"title":"对共有区块链系统加密货币流通机制的一些个人理解","date":"2018-01-27T10:32:44.000Z","path":"2018/01/27/2018-1-27/","text":"随着比特币价格的爆发式增长，最近几个月区块链在国内真是火的一塌糊涂，逢见互联网圈的朋友不用谈几句区块链都显得自己很low,从中本聪大神的比特币算起，区块链技术已经发展了近十年的时间，然而区块链技术对于平常人来讲确实有些难以理解，一是由于实际应用上的匮乏，区块链难以贴近生活，二是国内的科技公司在区块链技术方面之前几年缺乏足够关注，导致除了比特币等几个高价值数字货币外大家完全接触不到这类消息。 最近一段时间，EOS等号称底层区块链的ICO随处可见，我为了跟上时代，也抓紧时间学习了一下相关内容，画了一张底层区块链理想化运行模式的流程图方便自己理解和学习。 图中的token即我们常说的数字货币，在整个区块链系统中，token的作用不仅是货币，更是运作整个区块链系统的“燃油”，区块链上的应用必须保证token的消耗才能维持整个区块链系统的正常运作，这是为了保证挖矿机制的存在。矿场消耗现实世界的能源维持区块链系统运转，必须依靠token作为收益才能保证运转，而币市的存在又为token提供了变现和升值的功能。","tags":[{"name":"区块链","slug":"区块链","permalink":"https://popo1379.github.io/tags/区块链/"}]},{"title":"产品之路：久邦数码产品经理实习问题总结","date":"2018-01-26T07:05:49.000Z","path":"2018/01/26/2018-1-26/","text":"在GOMO的产品实习到此告一段落，回到老家放放寒假继续充电，总结这段工作经历，反思不足，为日后更好的工作做好准备 1 对产品进度控制力度不足： 尽管负责了部分产品的模块设计，但在后期与UI及研发同学的对接过程并不顺利，客观原因可能是初入职场，对公司运作流程的不了解。主观原因是自己的学院派气质，工作依旧带有码农作风，此后一定改正，入职后应先尽快熟悉同事职责及工作流程，对产品进度要做到心里有数 2 产品交互设计有待提高: 对产品的交互，仍有极大提高空间，近期考虑学习下产品设计相关课程，研读相关书籍 3 对产品背后市场和用户需求了解不够深入： 例如在负责数字货币产品时，没有对背后的市场和用户需求做更多的调查，相关竞品信息也不全面，导致产品在制作Demo过程中走了很多弯路，此后一定改正，多做产品调研，多分析竞品 4 对原型图及PRD文档版本管理不到位： 这是我平时最喜欢忽略的问题，原型图和文档在更新后，没有及时的通知相关的同学注意，导致在开会时经常会有同事拿着已经过期的文档提出意见，甚至拿过期原型进行开发，付出了大量的不必要的经历，再次向大家道歉！今后一定注意此类问题，争取提出一套高效的版本控制方案。","tags":[{"name":"产品经理","slug":"产品经理","permalink":"https://popo1379.github.io/tags/产品经理/"}]},{"title":"当战士变成法师 转职产品经理","date":"2017-08-22T13:14:37.000Z","path":"2017/08/22/2017-08-22/","text":"去年夏天一个偶然的机会开始接触产品经理这个职位，当时还在憧憬成为IT工程师的我可能做梦也没想到，自己会在一年后也成为产品中的一员。 大三期末考试后，我便开始了暑假实习的准备工作，经历了N次修改简历，终于成功拿到了三个面试邀请，第二次站在帝都火车站的广场上，看着熙熙攘攘的人群，琢磨着自己的未来。 感谢自己的高中兄弟还有东北电力的几个好同学能让我在北京有个临时落脚的地方，经过一周的面试成功拿到了实习Offer，在学长的帮助下租了间天通苑的小公寓，从此开始了伪北漂的生涯（我妈说你待不下去就赶紧回家，我也是抱着待不下去就跑的心态，所以叫伪北漂）。 目前在公司里实习了一个月了，从最开始的负责简单交互处理到现在能单独设计整个APP的功能流程，感觉一年多的Android开发经验完全可以转化为产品的设计技能，对交互设计的理解和与开发对接时的顺畅沟通。目前已经开始负责公司新美图产品的初版功能设计，就是不知道自己离开后这个产品还能不能顺利开发哈哈。 公司虽然是分公司，但是福利待遇让我这个东北来的孩子觉得还是蛮OK的，有无限量供应的零食和下午的水果，不知道是所有的互联网公司都这样还是特例，希望下家能有个免费吃饭的食堂哈哈，北京的外卖还是蛮贵的还吃不饱。 未来我将在博客中尽量多更新产品方面的学习笔记，当然我也可能继续更新技术方面新学习到的知识，但是大四要实习还要找工作做毕设还是蛮忙的，也不知道下篇会什么时候更新，就这样吧，领导又要开会了就不占用上班时间写博客了。 2017.8.22 北京","tags":[{"name":"产品经理","slug":"产品经理","permalink":"https://popo1379.github.io/tags/产品经理/"}]},{"title":"ORM框架 greenDAO3.0简单使用","date":"2017-04-22T10:09:12.000Z","path":"2017/04/22/2017-04-22/","text":"greenDAO是一个将对象映射到SQLite数据库中的轻量且快速的ORM解决方案。相较于原生的SQLite数据库，greenDAO3.0大幅降低对系统内存的开销，性能更好，易于优化精简。同时greenDAO也是目前为数不多坚持更新的Android ORM框架，近期推出的3.X版本广受开源社区好评。 使用方法： 前期准备工作：gradle引入1compile 'org.greenrobot:greendao:3.2.0' 在build.gradle中进行配置：APP1apply plugin: 'org.greenrobot.greendao' 项目： 123456789101112131415161718192021buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'org.greenrobot:greendao-gradle-plugin:3.2.1'//GreenDao &#125;&#125;``` Gradle Plugin的配置:```Javaandroid &#123;...&#125;greendao &#123; schemaVersion 1 //daoPackage 'com.greendao.gen' //targetGenDir 'src/main/java' &#125; 代码编写：一.创建bean例：1234567891011121314151617181920212223@Entity( schema = \"myschema\", active = true, nameInDb = \"AWESOME_USERS\", indexes = &#123; @Index(value = \"name DESC\", unique = true) &#125;, createInDb = false)public class User &#123; @Id(autoincrement = true) private Long id; @Property(nameInDb = \"USERNAME\") private String name; @NotNull private int repos; @Transient private int tempUsageCount; ...&#125; 在你创建的bean中加入@注解以方便greenDAO准确生成表1.实体@Entity注解 schema：告知GreenDao当前实体属于哪个schemaactive：标记一个实体处于活动状态，活动实体有更新、删除和刷新方法nameInDb：在数据中使用的别名，默认使用的是实体的类名indexes：定义索引，可以跨越多个列createInDb：标记创建数据库表 2.基础属性注解 @Id :主键 Long型，可以通过@Id(autoincrement = true)设置自增长@Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名 举例：@Property (nameInDb=”name”)@NotNul：设置数据库表当前列不能为空@Transient ：添加次标记之后不会生成数据库表的列 3.索引注解 @Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束@Unique：向数据库列添加了一个唯一的约束 4.关系注解 @ToOne：定义与另一个实体（一个实体对象）的关系@ToMany：定义与多个实体对象的关系 编写完bean类后编译项目，将自动生成DaoMaster 、DaoSession、Dao类，这样数据库就创建成功了，可以进行增删改查操作了。 二. 增删改查首先，我们要获取一个UserDao对象，这里建议直接在Application中进行初始化数据库操作12345678910111213141516171819202122232425262728293031public class MyApplication extends Application &#123; public static DaoSession mDaoSession; public static DaoSession searchDaoSession; public static Context mContext; // private static RefWatcher mRefWatcher; @Override public void onCreate() &#123; super.onCreate(); this.mContext = this.getApplicationContext(); initGreenDao(); &#125; //初始化数据库 private void initGreenDao() &#123; DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this,\"music_db\",null); Database db = helper.getWritableDb(); mDaoSession = new DaoMaster(db).newSession(); DaoMaster.DevOpenHelper helper1=new DaoMaster.DevOpenHelper(this,\"search_db\",null); Database db1 = helper.getWritableDb(); searchDaoSession=new DaoMaster(db1).newSession(); &#125; public static DaoSession getDaoSession()&#123; return mDaoSession; &#125; public static DaoSession getDaoSession1()&#123; return searchDaoSession; &#125;&#125; 这里我创建了两张表music_db和search_db 增12345//输入的内容添加至数据库 private void insertData(CharSequence charSequence) &#123; SearchNameBean searchNameBean=new SearchNameBean(null,String.valueOf(charSequence)); MyApplication.getDaoSession1().getSearchNameBeanDao().insert(searchNameBean); &#125; 2.查12//查询表中全部数据到容器中searchNameBeanList= MyApplication.getDaoSession1().getSearchNameBeanDao().loadAll(); 12//范围查找，where表示查询条件musicList=MyApplication.getDaoSession().getMusicBeanDao().queryBuilder().where(MusicBeanDao.Properties.Type.eq(Constant.MUSIC_LOCAL)).list() 3.改12searchNameBean = new SearchNameBean((long)2,\"000002\");MyApplication.getDaoSession1().getSearchNameBeanDao().update(searchNameBean); 4.删1MyApplication.getDaoSession1().getSearchNameBeanDao().deleteByKey(id)； 12//全部删除MyApplication.getDaoSession1().getSearchNameBeanDao().deleteAll()； 三.数据库升级1修改gradle文件12345greendao &#123; schemaVersion 2 //daoPackage 'com.greendao.gen' //targetGenDir 'src/main/java' &#125; 2修改bean 3重新编译","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"算法分析笔记：JAVA运行时间复杂度计算","date":"2017-03-23T08:56:11.000Z","path":"2017/03/23/2017-03-23/","text":"一 数学基础： 定义： 如果T(N)增长率&lt;=f(N)增长率，则T(N)=O(f(N)) (大O标记) 如果T(N)增长率&gt;=f(N)增长率，则T(N)=Ω(f(N)) 如果T(N)增长率=f(N)增长率，则T(N)=Θ(f(N)) 如果T(N)增长率&lt;f(N)增长率，则T(N)=o(f(N)) 法则1：如果T1(N)=O(f(N))且T2(N)=O(g(N)) 则 T1(N)+T2(N)=O(f(N)+g(N)) T1(N)T2(N)=O(f(N)g(N)) 法则2： 如果T(N)是一个K次多项式，T(N)=Θ(N^K) 法则3： 对于任意的常数k,(logN)^k = O(N) 法则4： 常数项或低阶项不要放入O（）中。 二：运行时间复杂度计算 1.for循环123for(int i=0;i&lt;N;i++)k++ ; //这里运行次数为N次,时间为O(N) 2.嵌套for循环123for(i=0;i&lt;N;i++)for(j=0;j&lt;N;j++) k++ ; //这里运行次数为N次,时间为O(N) 3.顺序语句123456for(i=0;i&lt;N;i++)k++ ;for(i=0;i&lt;N;i++)for(i=0;j&lt;N;j++) Z++ ; //按顺序将for循环运行复杂度依次相加，O(N)+O(N^2),总量为O(N^2) 3.if/else 1234if(condition)S1elseS2 //运行时间不超过S1和S2运行时间长者的总运行时间 三：关于多重复杂for的复杂度计算1234for(int i=1;i &lt;=n;i++)for(int j=1;j &lt;=i;j++) for(int k=1;k &lt;=j;k++) Z++; 计算过程：1.先从最内层开始计算，Z++复杂度为12.最内层循环：j次3.第二次循环：i*(1+i)/24.最外层循环: n (n + 1) (n + 2)/6=O(N^3)","tags":[{"name":"CS基础","slug":"CS基础","permalink":"https://popo1379.github.io/tags/CS基础/"}]},{"title":"RXJAVA+Retrofit+MVP框架 网难新闻","date":"2017-03-02T06:39:10.000Z","path":"2017/03/02/2017-03-02/","text":"寒假期间为了学习MVP框架，在网上找了好多Demo，琢磨了好长时间，MVP框架相比传统的MVC，需要更多的接口和业务类来实现功能，但其解耦性能也更好，提高了代码的可维护性和测试性能，实现了功能模块化，因此如果是需要多人合作的大项目显然MVP框架更适合项目开发 网难新闻项目思路：启动APP—-&gt;启动NewsFragment—–&gt;触发presenter中的requestNetWork()——-&gt;触发model中的netWorkNewsList()——-&gt;触发Retrofit发出数据请求——–&gt;RXJAVA将返回的数据载入容器中——–&gt;容器传入配适器 数据源使用了聚合数据 Github项目地址：https://github.com/popo1379/NetHardNEWSV0.01 VIEW部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public class NewsFragment extends BaseFragment implements SwipeRefreshLayout.OnRefreshListener, MyRecyclerView.LoadingData, BaseRecyclerViewAdapter.OnItemClickListener&lt;GamesBean&gt;, BaseView&lt;GamesBean&gt;&#123; private SwipeRefreshLayout srfLayout; private MyRecyclerView recyclerView; private GamesListAdapter gamesListAdapter; private boolean isPrepared; private boolean isLoad; private GamesListPresenter gamesListPresenter; private String type = \"top\"; private BannerViewPager bannerViewPager; private ImageView iv1,iv2,iv3,iv4,iv5; @Override protected View initView() &#123; if (view == null) &#123; view = View.inflate(UIcollector.getActivity(), R.layout.fragment_news, null); recyclerView = (MyRecyclerView) view.findViewById(R.id.news_recyclerview); srfLayout = (SwipeRefreshLayout) view.findViewById(R.id.srf_layout); isPrepared = true; bannerViewPager = (BannerViewPager)view.findViewById(R.id.banner); iv1 = (ImageView) LayoutInflater.from(UIcollector.getActivity()).inflate(R.layout.banner_item,bannerViewPager,false); iv2 = (ImageView) LayoutInflater.from(UIcollector.getActivity()).inflate(R.layout.banner_item,bannerViewPager,false); iv3 = (ImageView) LayoutInflater.from(UIcollector.getActivity()).inflate(R.layout.banner_item,bannerViewPager,false); iv4 = (ImageView) LayoutInflater.from(UIcollector.getActivity()).inflate(R.layout.banner_item,bannerViewPager,false); iv5 = (ImageView) LayoutInflater.from(UIcollector.getActivity()).inflate(R.layout.banner_item,bannerViewPager,false); &#125; return view; &#125; @Override protected void initData() &#123; if (!isPrepared || !isVisible || isLoad) &#123; return; &#125; LinkedList&lt;GamesBean&gt; list = new LinkedList&lt;&gt;(); gamesListAdapter = new GamesListAdapter(list); gamesListAdapter.setOnItemClickListener(this); gamesListPresenter= new GamesListPresenter(this); srfLayout.setOnRefreshListener(this); recyclerView.setHasFixedSize(true); recyclerView.setLoadingData(this); recyclerView.setLayoutManager(new StaggeredGridLayoutManager(1, LinearLayoutManager.VERTICAL)); recyclerView.setAdapter(gamesListAdapter); iv1.setImageResource(R.drawable.main_viewpager_pic1); iv2.setImageResource(R.drawable.main_viewpager_pic2); iv3.setImageResource(R.drawable.main_viewpager_pic3); iv4.setImageResource(R.drawable.main_viewpager_pic4); final List&lt;ImageView&gt; mViews = new ArrayList&lt;&gt;(); mViews.add(iv1); mViews.add(iv2); mViews.add(iv3); mViews.add(iv4); mViews.add(iv5); //实例化ViewPagerAdapter，第一个参数是View集合，第二个参数是页面点击监听器 ViewPagerAdapter mAdapter = new ViewPagerAdapter(mViews, new OnPageClickListener()&#123; @Override public void onPageClick(View view, int position) &#123; Log.d(\"cylog\",\"position:\"+position); &#125; &#125;);//设置适配器 bannerViewPager.setAdapter(mAdapter); srfLayout.post(new Runnable() &#123; @Override public void run() &#123; onRefresh(); &#125; &#125;); isLoad = true; &#125; @Override public void setData(List&lt;GamesBean&gt;datas) &#123; if (datas.isEmpty()) &#123; isNull = true; &#125; else &#123; gamesListAdapter.addAll(datas); &#125; &#125; @Override public void onRefresh() &#123; gamesListAdapter.removeAll(); gamesListPresenter.requestNetWork(type,isNull); &#125; @Override public void onLoadMore() &#123; gamesListAdapter.removeAll(); gamesListPresenter.requestNetWork(type,isNull); &#125; @Override public void netWorkError() &#123; Toast(UIcollector.getString(R.string.network_error)); &#125; //刷新开关：开 @Override public void showProgress() &#123; if (!srfLayout.isRefreshing()) &#123; srfLayout.setRefreshing(true); &#125; &#125;//刷新开关：关 @Override public void hideProgress() &#123; if (srfLayout.isRefreshing()) &#123; srfLayout.setRefreshing(false); &#125; &#125; @Override public void showFoot() &#123; gamesListAdapter.isShowFooter(true); &#125; @Override public void hideFoot() &#123; gamesListAdapter.isShowFooter(false); &#125; @Override public void onItemClick(View view, int position, GamesBean info) &#123; gamesListPresenter.onClick(info); Log.i(\"NewsFragment\",\"onItemClick被调用了\"); &#125; &#125; Presenter：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class GamesListPresenter extends BasePresenter&lt;BaseView&gt; implements BeanDate&lt;GamesBean&gt;,GamesData &#123; private final BaseModel.GamesListModel gamesListModel; public GamesListPresenter(BaseView mView)&#123; attach(mView); this.gamesListModel = new GameListModelImpl(); &#125; public void requestNetWork(String type, boolean isNull) &#123; LogUtils.i(\"GamesListPresenter\",\"GamesListPresenter的requestNetWork被调用了\"); if (!isNull) &#123; mView.showFoot(); &#125; gamesListModel.netWorkGamesList(type, this); &#125; public void addData(List&lt;GamesBean&gt; datas)&#123; mView.setData(datas); mView.hideFoot(); mView.hideProgress(); &#125; @Override public void error()&#123; mView.hideFoot(); mView.hideProgress(); mView.netWorkError(); &#125; public void onClick(GamesBean info) &#123; NewshowActivity.startIntent(info.getUrl()); Log.i(\"onClick\",info.getTitle()+\"into webview\"); &#125;&#125; Model1234567891011121314151617181920212223242526public class GameListModelImpl implements BaseModel.GamesListModel&#123; public void netWorkGamesList(String type ,final GamesData gameData) &#123; NetWorkRequest.gamesList(type, new MySubscriber&lt;JUHEBean&gt;() &#123; @Override public void onCompleted() &#123; Log.i(\" GameListModelImpl\", \" GameListModelImpl的onCompleted被调用了\"); &#125; @Override public void onError(Throwable e) &#123; gameData.error(); &#125; @SuppressWarnings(\"unchecked\") @Override public void onNext(JUHEBean gameNewsListBean) &#123; gameData.addData(gameNewsListBean.getResult().getData()); &#125; &#125;); &#125;&#125; 网络请求：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NetWork &#123; private static final Converter.Factory gsonConverterFactory = GsonConverterFactory.create(); private static final CallAdapter.Factory rxJavaCallAdapterFactory = RxJavaCallAdapterFactory.create(); private static JUHEAPI juheapi; public static JUHEAPI getJUHEAPI()&#123; if (juheapi == null) &#123; juheapi = getRetrofit(Api.BASE_API_JUHE).create(JUHEAPI.class); &#125; return juheapi; &#125; private static Retrofit getRetrofit(String baseUrl) &#123; return new Retrofit.Builder() .client(new OkHttpClient.Builder().addInterceptor(new LogInterceptor()).build()) .baseUrl(baseUrl) .addConverterFactory(gsonConverterFactory) .addCallAdapterFactory(rxJavaCallAdapterFactory) .build(); &#125; private static class LogInterceptor implements Interceptor &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Log.i(\"LogUtils--&gt; \", \"request:\" + request.toString()); okhttp3.Response response = chain.proceed(chain.request()); okhttp3.MediaType mediaType = response.body().contentType(); String content = response.body().string(); Log.i(\"LogUtils--&gt; \", \"response body:\" + content); if (response.body() != null) &#123; ResponseBody body = ResponseBody.create(mediaType, content); return response.newBuilder().body(body).build(); &#125; else &#123; return response; &#125; &#125; &#125;&#125; 123456789101112public class NetWorkRequest &#123; public static void gamesList(String type,Subscriber&lt;JUHEBean&gt; subscriber) &#123; Rxjavacollector.unsubscribe(); Rxjavacollector.subscription = NetWork.getJUHEAPI().getGamesList(type,Api.NEWS_KEY) .subscribeOn(Schedulers.io()) .unsubscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); &#125;&#125;","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"View点击事件分发机制","date":"2017-02-05T09:51:53.000Z","path":"2017/02/05/2017-02-05/","text":"点击事件的分发过程由三个方法构成： public boolean dispatchTouchEvent(MotionEvent event) 用来进行事件分发，如果事件能传递给当前View，此方法将被调用，返回结果受onInterceptTouchEvent()和onTouchEvent()影响。该方法返回结果表示是否消耗当前View事件 public boolean onInterceptTouchEvent(MotionEvent event) 在dispatchTouchEvent方法中调用，表示是否拦截该事件。返回结果表示是否拦截该事件 public boolean onTouchEvent(MotionEvent event) 表示处理点击事件，返回结果表示是否消费当前事件。 View源代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 简化后伪代码：1234567891011121314151617public boolean dispatchTouchEvent(MotionEvent event)&#123; boolean result=false; if(onInterceptTouchEvent(event))&#123; //如果截获view事件，即调用onTouchEvent() result=onTouchEvent(event); &#125; else&#123; //如果不截获那么当前事件将继续传递给子元素继续调用dispatchTouchEvent方法直至事件被处理 result=child.dispatchTouchEvent(event); &#125; return result;&#125;","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"View基础知识","date":"2017-01-31T08:47:28.000Z","path":"2017/01/31/2017-1-31/","text":"View是Android中所有控件的基类，是控件的一种抽象，在Android中无论是Button还是ListView甚至常用的RelativeLayout其实都是View。除了View外还有ViewGroup(控件组)，即一组控件，它继承自View，在ViewGroup内部也可以存在View，因此整个关系构成了一个View树。 一 View的位置参数View的位置主要由四个顶点来决定，四个顶点分别对应View的四个属性：top、left、right、bottom。left:左上角横坐标top：左上角纵坐标right:右下角横坐标bottom：右下角纵坐标 因此，我们可以得出View的宽高与坐标的关系： 12width=right-leftheight=bottom-top 获取这四个顶点：1234567left=getLeft();right=getRight();top=getTop();bottom=getBottom(); Android3.0之后，View新增了几个参数:x、y、translationX和translationY，xy是View左上角坐标，translationX和translationY是View左上角的相对于父容器的偏移量。几个参数的换算关系如下：123x= left + translationX；y=top +translationY； 这里需要注意的是，View在平移过程中，top和left代表的是原始左上角的位置信息，值不会发生变化，此时发生变化的是x,y,translationX和translationY。 二 View触摸事件 在手指接触屏幕后所产生的一系列事件中,典型的事件类型有如下几种: ACTION_DOWN : 手指刚接触屏幕 ACTION_MOVE : 手指在屏幕上移动 ACTION_UP : 手指离开屏幕的一瞬间 正常情况下,一次手指触摸屏幕的行为会触发一系列点击事件，例如: A. 点击屏幕后离开，事件序列为DOWN-&gt;UP; B. 点击屏幕滑动一会松开，事件序列为DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP; 通过MotionEvent对象我们可以获得点击事件发生的x和y坐标，Android提供了两组方法:getX/getY和getRawX/getRawY。getX和getY返回的是相当于当前View左上角的x和y坐标,而getRawX和getRawY返回的是相对于手机屏幕左上角的x和y坐标。 三 TouchSlop TouchSlop是系统所能识别出的滑动的最小距离。当两次滑动距离小于TouchSlop时，默认为不滑动。使用下列方式可以获得最小距离：1ViewConfiguration.get(getContext()).getScaledTouchSlop(); 四 VelocityTrackerVelocityTracker是速度追踪，用追踪用户在滑动过程中的速度，包括水平和竖直方向的速度。使用方法：12345678910111213VelocityTracker velocityTracker=VelocityTracker.obtain();velocityTracker.addMovement(event);vt.computeurrentVelocity(100); //间隔为100msInt x=(int)velocityTracker.getXVelovity();Int y=(int)velocityTracker.getYVelovity();velocityTracker.clear(); //关闭方法velocityTracker.recycle(); 五 GestureDetector 手势检测，用于辅助检测用户的单击，滑动，长按，双击等行为。 我们创建一个GestureDetector对象并实现onGestureListener接口,根据需要我们还可以实现onDoubleTapListener从而能够监听双击行为: 12345GestureDetector mGestureDetector =new GestureDetector(this);//解决长按屏幕无法拖动的现象mGestureDetector.setIsLongPressEnable(false); 接管目标View的onTouchEvent方法：12Boolean consume=mGestureDetector.onTouchEvent(event);return consume; 完成上面两步，我们就可以选择OnGestureListener方法，方法如下： 按下（onDown）： 刚刚手指接触到触摸屏的那一刹那，就是触的那一下。抛掷（onFling）： 手指在触摸屏上迅速移动，并松开的动作。长按（onLongPress）： 手指按在持续一段时间，并且没有松开。滚动（onScroll）： 手指在触摸屏上滑动。按住（onShowPress）： 手指按在触摸屏上，它的时间范围在按下起效，在长按之前。抬起（onSingleTapUp）：手指离开触摸屏的那一刹那。","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"Context笔记","date":"2017-01-20T05:53:07.000Z","path":"2017/01/20/2017-01-20/","text":"Context(场景)是在Android开发中最常用到的核心类，它实现了组件与系统交互的功能，本文是关于Context的一些琐碎学习内容。 如何全局获得Context: 自定义Application类： 123456789101112public class MyApplication extends Application &#123; private static Context context; @Override public void onCreate() &#123; //获得Context context = getApplicationContext(); &#125; public static Context getContext()&#123; return context; &#125; &#125; 项目中需要使用Context直接 调用MyApplication.getContext() Context应用场景： 数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。 有时为了避免出现内存泄露现象，引用ApplicationContext而不是Context，由于Application与APP生命周期一致，可以避免内存泄露，但是在有些应用场景中不能使用ApplicationContext，这点需要注意。 Context数量： Context数量 = Activity数量 + Service数量 + 1(Application) Context继承关系：","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"性能优化：内存泄露常见案例及优化方案","date":"2017-01-15T12:08:38.000Z","path":"2017/01/15/2017-1-15/","text":"内存泄露，是指对象不再使用但无法回收造成的内存无法释放造成大量被占用现象，在所有的软件开发中，都有内存泄露现象，众所周知，JAVA拥有自己的内存回收机制：当对象不再调用后系统自动回收，相较于C++等语言，JAVA这一机制使得开发工作更为容易，开发者能将精力更多的放在实现代码逻辑上，但实际上JAVA中也有许多情况会造成对象无法回收，由于JAVA的特性这一现象更容易被程序员忽略，于是造成了内存泄露，到了Android平台上，由于手机内存限制，内存泄露所造成的影响更大，因此，解决内存泄露问题是程序员开发过程中必须要面对的问题。如何解决内存泄露，一方面，需要避免在开发过程中写出造成内存泄露的代码逻辑。另一方面，则要通过专门的工具检测潜在的内存泄露并解决问题，在google的AndroidStudio中自带内存检查工具，同时我们也可以使用MAT这类插件排查问题。 1.静态变量造成的内存泄露：这应该是初级开发者最容易遇到的错误，在Activity中加入了一个静态变量，它内部持有了当前的Activity对象，因此Activity无法被销毁123456789public class MainActivity extends Activity&#123; public static Context context; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; &#125; &#125; 解决方案：使用Application的Context,这里建议在开发前先做一个全局Context，免得到时候麻烦 2.单例模式造成的内存泄露单例模式的特点是其生命周期和Application一样长，如果一个单例对象1持有了一个对象2的引用，那么这个对象2就不能正常被回收，只能等和应用一起挂掉12345678910111213public class DemoManager &#123; private static AppManager instance; private Context context; private DemoManager(Context context) &#123; this.context = context; &#125; public static DemoManager getInstance(Context context) &#123; if (instance != null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 解决方案和上面一样，传入的Context直接Application的Context，别写Activity. 3.使用Handlder不当造成的内存泄漏：123456789101112131415public class MainActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); handler.sendMessageDelayed(Message.obtain(), 60000); finish(); &#125; private final Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // 逻辑 &#125; &#125;; 由于handler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道msg队列是在Looper线程中轮流处理msg，那么当这个Activity退出时消息队列中还有未处理的msg或者正在处理msg，而msg队列中的Message持有handler实例的引用，handler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。解决方案：直接在Activity关闭方法中使用removeCallbacksAndMessages()方法传入null，实际上还可以通过软引用解决问题，但是场合不多见。1234@Override public void onDestroy() &#123; handler.removeCallbacksAndMessages(null); &#125; 4.属性动画导致的内存泄露当我们在Activity中播放动画时，Activity中的View被动画持有，View又持有Activity,因此即使我们看不到动画效果，Activity依然无法被释放，解决方案也很简单，在onDestry方法中调用animator.cancel()停止动画。","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"Android开发进阶之Activity启动模式探究","date":"2017-01-12T13:41:41.000Z","path":"2017/01/12/2017-01-12/","text":"在Android运行机制中，当你启动一个Activity时，系统会将这个Activity创建实例并放入任务栈中，不同的启动模式，将决定Activity启动方式的不同以及与任务栈之间的关系，设置一个恰当的启动模式将使用户体验得到质的飞跃。 任务栈(task stack)也叫退回栈，当我们使用返回键时，会发现页面会一一退回，因为任务栈是一种“后进先出”的结构，当我们按返回键时，Activity会一一出栈，直至全部出栈后系统回收任务栈。大部分情况下，一个应用程序拥有一个任务栈。 在Android中目前拥有4个启动模式，分别是standard、singleTop、singleTask以及singleInstance下面将一一介绍。 (1)standard:标准模式，就是系统默认的启动模式，当我们不对Activity做任何设置时系统将默认使用标准模式，这个模式很好理解，就是每次启动Activity都将重新创建一个新的实例，不管这个实例是否存在，被创建的实例进行正常的生命周期情况，即onCreate-&gt;onStart-&gt;onResume.在这种模式下，谁启动了这个Activity。这个Activity就存在于启动它的那个Activity的任务栈中，也就是说，我们在Activity A中启动了Activity B，这时B存在于A所在的任务栈中，此时任务栈结构为AB，这时如果我们再启动B，任务栈结构将为ABB。 (2)singleTop：栈顶复用模式。在这种模式下，如果想要启动的Activity一经存在于任务栈顶端，那么启动时将不再重新创建，生命周期中的onCreate和onStart将不会调用。同时，它的onNewIntent方法将被回调，使用此方法我们将可以取出当前的请求信息。举个例子，栈内有Activity A和B C，C在栈顶为singleTop模式，这时我们再启动C，C将不会被创建，栈结构依旧为ABC，但如果C启动模式为standard，这时再启动C，栈结构实际为ABCC，因为C被重新创建了。 (3)singleTask:栈内复用模式。在这种情况下，只要Activity在一个栈内存在，那么再次启动该Activity将不会重新创建实例，并且系统也将回调onNewIntent。例如在此模式下启动一个Activity A，系统将先查看该任务栈内是否存在A，如果存在，将A调至栈顶并调用onNewIntent方法，如果没有A，则重新创建A。需要注意的是，当A存在并调至栈顶的过程中，将会导致A上面的Activity被清出栈。 (4)singleInstance:单实例模式。顾名思义，即任务栈中只存在有这一个Activity，如果存在，不调用，不存在则重新创建。特性类似singleTask。例如Activity A(假设任务栈为01)启动singleInstance模式的B，B将单独存在于任务栈02中，请注意，这时如果再通过B启动C，C启动模式不是singleInstance时，将自动归至任务栈01中。 下面我们来介绍设置启动模式的两种方法：第一种，在Manifest中设置启动模式：123&lt;activity android:name=\".MainActivity\" android:launchMode=\"singleTask\"&gt; &lt;/activity&gt; 另一种则是在Intent中通过设置标志位指定启动模式1234Intent intent=new Intent(); intent.setClass(MainActivity.this,SecondActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 二者都可以设置启动模式，但仍有区别，首先优先级上第二种优先第一种，即如果通过上述两种方法设置了两个启动模式，系统以第二种为准，另外第二种方法无法设置singleInstance模式。","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"Android开发进阶：探究Activity生命周期及异常情况分析","date":"2017-01-10T03:29:21.000Z","path":"2017/01/10/2016-01-10/","text":"Activity作为Android四大组件之首，是我们开发使用过程中接触最为频繁的一种组件，Activity承担着与用户交互等最重要的功能，因此这里将全面分析Activity生命周期作为进阶的第一个重要知识。1.正常情况下生命周期分析 onCreate : 该方法表示Activity正在被创建，在这里，我们将进行一些初始化工作，如通过setContentView设置界面布局的资源，初始化所需要的组件信息等。onStart : 此方法被回调时表示Activity正在启动，这时Activity已经可见了，但还没有出现在前台，我们可以理解为此时Activity已经准备就绪，但还没有在屏幕中显示出来onResume : 当此方法回调时，则说明Activity已在前台可见，此时用户已经可以看见Activity并可以与之交互了，如此我们可以看作onStart时Activity还在后台，而onResume时Activity已经显示到了前台onPause : 此方法被回调时则表示Activity正在停止，一般情况下onStop方法会紧接着被回调。但通过流程图我们还可以看到一种情况是onPause方法执行后直接执行了onResume方法，这属于比较极端的现象很难再现，此时onResume方法就会被回调。在onPause方法中我们可以做一些不耗时的逻辑，例如停止动画等。需要注意！！！onPause方法执行完成后，新Activity的onResume方法才会被执行，因此如果在onPause中添加耗时逻辑将影响新界面的生成。onStop : 一般在onPause方法执行完成直接执行，表示Activity即将停止，此时Activity不可见，仅在后台运行。同样地，在onStop方法可以做一些资源释放的操作（不能太耗时）。onRestart :表示Activity正在重新启动，当Activity由不可见变为可见状态时，该方法被回调。这种情况一般是用户打开了一个新的Activity时，当前的Activity就会被暂停（onPause和onStop被执行了），接着又回到当前Activity页面时，onRestart方法就会被回调。onDestroy :此时Activity正在被销毁，也是生命周期最后一个执行的方法，我们可以在此方法中做一些回收工作和最终的资源释放。 这里说明几种常见情况：(1)当用户第一次启动Activity时，调用onCreate-&gt;onStart-&gt;onResume-&gt;正常运行(2)当用户打开新Activity或回到桌面时调用onPause-&gt;onStop(3)当用户回到该Activity时，调用onRestart-&gt;onStart-&gt;onResume-&gt;正常运行(4)当用户使用返回键回退时，onPause-&gt;onStop-&gt;onDestroy，程序销毁，再次开启时按方法1重新调用函数运行 2.异常情况下生命周期 在Activity生命周期中，除了上述几种用户操作情况外，还有一些异常情况，最常见的异常情况主要为两种,一种是由于系统内存不足导致Android启动kill机制杀死进程防止卡死，另一种则是由于系统配置改变造成的异常情况，下面我们逐一进行分析 首先我们先介绍两种新的方法：onSaveInstanceState:用于在Activity销毁时保存Activity相关的对象信息onRestoreInstanceState：被销毁的Activity重建时取出之前保存的信息 实际上，系统调用这两种方法调用的场景有许多，例如HOME键退回桌面，电源键熄灭屏幕，屏幕切换Activity等，我们在上述情况下数据信息依然得意保留就是靠这两个方法。 (1)内存不足造成的异常情况首先，我们要知道，Activity拥有优先级，优先级取决于Activity自身的状态优先级：前台Activity&gt;可见的但非前台Activity&gt;后台Activity 当系统内存不足时，系统就会按照优先级从小到大依次杀死目标进程，并在之后调用onSaveInstanceState和onRestoreInstanceState方法储存恢复数据信息。因此，许多后台工作不适合放在Activity中，我们应该使用Service放置后台，从而保证拥有较高的优先级而不被杀死 (2)由于系统配置改变造成的异常情况 系统配置异常情况，常见于竖屏手机横置，在默认情况下，Activity会销毁并重新创建，此时，系统将调用onSaveInstanceState方法保存当前的信息，例如当前的试图结构，文本框中的数据，列表滚动位置等等。","tags":[{"name":"Android开发","slug":"Android开发","permalink":"https://popo1379.github.io/tags/Android开发/"}]},{"title":"Hello my 2017","date":"2016-12-31T11:08:48.000Z","path":"2016/12/31/2016-12-31/","text":"在写这篇文章的时候，距离2017年还有4小时31分，2016年的进度条即将到达终点，逝去的时间不会重返，未来的生活依旧充满挑战与挫折，想总结这一年来的生活,学习，数年过后，再来看看，看看有没有遗憾，有没有忘记的人，忘记的事。 在2016年年初 获得了大学的第一笔奖学金，虽然数目不大，但也算是一种鼓励吧3月 卖掉了心爱的微单暂停摄影活动，准备未来换台更好的，现在看来也不知道啥时候能落实……4月 我决定了未来的职业方向，开始学习Android,在图书馆里啃了一个月的《Java编程思想》，开启了我人生的新世界5月 开始每天晚上到操场跑步减肥，现在不控制恐怕以后就晚了吧7月 个人制作的第一个Android软件《掌上化院》完成，现在看来代码写的很幼稚，功能上还有数不清的BUG，如果明年有空大概会重构同月 开始去健身房健身，买到了心仪许久的樱桃红轴键盘，写代码很爽8月 开始学习前端技术，目前第一个项目已经开始了9月 开学 开发了APP《网难云音乐》，学到了不少知识，受益匪浅10月 架设了我的个人博客 www.popo1379.com 并尝试写技术日记 接触了微信小程序，目前仍在观望，觉得是个机会11月份 开发高仿版QQ，目前项目遇到很大问题，考虑更换框架12月份 前往北京参加Google开发者大会，第一次看到天安门和鸟巢，对北京印象很棒！ 考试月。天天泡图书馆学习 2017年，希望自己的技术能有卓越的提升 希望能好好学习外语 希望能找到一份适合的工作 希望家人身体健康 希望生活少些痛苦，多些惊喜 我对未来仍旧充满期待。","tags":[{"name":"个人生活","slug":"个人生活","permalink":"https://popo1379.github.io/tags/个人生活/"}]},{"title":"Google开发者大会(北京)一日游实记","date":"2016-12-11T14:26:16.000Z","path":"2016/12/11/2016-12-11/","text":"12月8日，Google在时隔5年后再一次在中国举办开发者大会，能参与在Google离开中国后第一次开发者大会，很激动能够见证这次盛会，把在现场的照片发出来，记录下来，留个纪念。 大会地点在国家会议中心，就在奥林匹克公园旁边，交通很方便，地铁8号线直通七点半到的时候已经排起长队了，国内的开发者很是热情啊，另外大会上的工作人员妹子都很漂亮哈哈。 大会主会场大屏幕，这很Google 9点大会正式开始，首先是演示最新的VR体感游戏技术，机器目测是HTC的VIVE,话说VR现在还真是火啊，Google自己也搞了一个手机上的VR开发平台Daydream,中午在体验区体验了一下，感觉还不错。 VR演示过后，Google大中华区总裁Scott上台发言，总裁表示中国的市场很大，中国开发者们有着很强的国际竞争力。 之后是Google全球开发者产品总监Ben,Ben表示我们为中国的开发者提供了中文版的开发者网站，网站地址已经给出，之后Ben提到国内公司使用Google技术开发案例，其中举例了阿里巴巴，Google一直在你们身边 随后主会场结束，几个分会场开始，Android分会场： 工程师主要介绍了Android 7.1版本的新特性，开发指南等，另外也重点提到了国内的Android开发环境，希望开发者们能遵守Google的开发设计规则，从用户体验出发。 午餐自助吃的不错啊哈哈 奉上本人帅照 总结： 可以看出主办方为本次活动准备了很多，据说为了这场大会Google准备了半年的时间。时隔5年，Google离开中国的几年正是中国互联网高速发展的几年，这次的开发者大会也是告诉人们google对中国市场和开发者的重视，希望google能够早日回到中国吧。","tags":[{"name":"个人生活","slug":"个人生活","permalink":"https://popo1379.github.io/tags/个人生活/"}]},{"title":"Android SQLite数据库使用指南","date":"2016-12-02T11:54:26.000Z","path":"2016/12/02/2016-12-2/","text":"SQLite数据库是一款轻量化的关系型数据库，它具有速度快，占用资源少优点，相对于SharedPrefences,SQLite更适合储存大量复杂的关系型数据。Android中非常贴心的内嵌了SQLite数据库，免去了安装其它框架的麻烦，为本地持久化数据功能的实现提供了可靠的方法。 一 创建数据库Android专门提供了SQLiteOpenHelper类供我们创建和升级数据库，它的使用方法非常简单，下面让我们来看一看首先，SQLiteOpenHelper是一个抽象类，它提供了两个抽象方法：onCreate()和onUpgrade(),在数据库继承SQLiteOpenHelper类时我们需要重写这两个方法以实现创建和升级数据库的逻辑。另外，该类还有两个实例方法：getReadableDatabase()和getWritableDatabase(),这两个方法都可以创建或打开一个现有的数据库，并返回一个可对数据库进写读操作的对象，不同的是，当数据库不可写入时，getReadableDatabase()可以正常以只读的方式打开数据库，而getWritableDatabase()将出现异常。 下面，我们创建一个名为Student.db的数据库，然后在这个数据库中创建一个Stduent表，建表语句如下:1234567create table Student(StudentID integer,studentName text,math integer,chinese integer,english integer) 代码如下：1234567891011121314151617181920212223242526public class StudentHelper extends SQLiteOpenHelper &#123; public static final String Student = \"create table Student(\" +\"StudentID integer,\" +\"studentName text,\" +\"math integer,\" +\"chinese integer,\" +\"english integer)\"; private Context mContext; public StudentHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,int version)&#123; super(context,name,factory,version); mContext=context; &#125; @Override public void onCreate(SQLiteDatabase db)&#123; db.execSQL(Student); Toast.makeText(mContext,\"创建数据库成功\",Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion,int newVersion) &#123; &#125;&#125; 在主布局中添加一个按钮用于创建数据库12345&lt;Button android:id=\"@+id/create_database\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"create_database\"/&gt; 主活动代码：123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; private StudentHelper studentHelper; private Button create_btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); studentHelper = new StudentHelper(this,\"Student.db\",null,1); create_btn=(Button) findViewById(R.id.create_database); create_btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; studentHelper.getWritableDatabase(); &#125; &#125;); &#125;&#125; 注意！我们构建了一个StudentHelper对象，通过传入参数将数据库定名为”Student.db”，指定了版本号为1，然后在按钮监听事件中写入getWritableDatabase()方法用以操作数据库，当点击按钮时，系统将检测程序是否存在”student.db”数据库，第一次点击由于并没有数据库，系统将调用StudentHelper中的onCreate()方法创建数据库，此时我们的Toast将弹出以提示创建数据库成功。再次点击，由于已经存在数据库，因此将不会调用onCreate()弹出Toast。 二 升级数据库在之前的代码中，我们注意到还有一个空方法onUpgrade还没有用，这个方法是用于对数据库进行升级的，下面我们更新一个新的建表语句：1234create table StudentUp( physics integer, chemistry integer) 加入数据库中：12345678910111213141516171819202122232425262728293031323334353637public class StudentHelper extends SQLiteOpenHelper &#123; public static final String Student = \"create table Student(\" +\"StudentID integer,\" +\"studentName text,\" +\"math integer,\" +\"chinese integer,\" +\"english integer)\"; public static final String StudentUp= \"create table StudentUp(\" +\"physics integer,\" +\"chemistry integer)\"; private Context mContext; public StudentHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,int version)&#123; super(context,name,factory,version); mContext=context; &#125; @Override public void onCreate(SQLiteDatabase db)&#123; db.execSQL(Student); db.execSQL(StudentUp); Toast.makeText(mContext,\"创建数据库成功\",Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion,int newVersion) &#123; /** * 我们在onUpgrade()方法中执行了两条DROP语句，如果在数据库中已经存在Student或StudentUp表，就会将表删除，然后再调用 * onCreate方法重新创建，因为如果在创建表时发现表已经存在，就会报错 */ db.execSQL(\"drop table if exists Student\"); db.execSQL(\"drop table if exists StudentUp\"); onCreate(db); &#125; &#125; 接下来我们需要让onUpgrade方法得到执行，前面studentHelper = new StudentHelper(this,”Student.db”,null,1);这句代码里的第四个参数1，它代表当前数据库的版本号，之前我们传入了1，现在我们只需要传入一个比1大的数，就可以使onUpgrade()方法得到执行，因此我们将代码修改为1studentHelper = new StudentHelper(this,\"Student.db\",null,2); 三 添加数据SQLiteDatabase中提供了一个insert()方法用于添加数据，它接收三个参数，第一个参数是表明，表示我们希望向哪个表添加数据，第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能所以直接传入null就OK了，第三个参数是一个ContentValues对象，它提供了一系列的put()方法重载，用于向ContentValues提供数据，下面我们修改代码： 添加一个新的按钮用于添加数据：12345&lt;Button android:id=\"@+id/addData\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"addData\"/&gt; 在原代码添加下列逻辑1234567891011121314Button add_btn=(Button) findViewById(R.id.addData); add_btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; SQLiteDatabase db=studentHelper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put(\"StudentID\",1410912219); values.put(\"studentName\",\"李四\"); values.put(\"math\",86); values.put(\"chinese\",92); values.put(\"english\",72); db.insert(\"Student\",null,values); &#125; &#125;); 这样，我们就成功添加数据到Student表中了，注意！如果要添加第二段数据，请先调用values.clear()清空ContentValues内的数据。 四 更新数据SQLiteDatabase中提供了一个update()方法用于对数据进行更新，这个方法接收四个参数，第一个参数是表名，第二个参数是ContentValues对象，要把更新数据在这里组装进去，第三第四个参数用来约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行。 逻辑代码：1234SQLiteDatabase db=studentHelper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put(\"math\",65); db.update(\"Student\",values,\"studentName=?\",new String[]&#123;\"李四\"&#125;); 注意，在这里我们将数学成绩更新为65分，第三个参数指定了名字等于？的行，第四个参数提供了一个字符串数组用于给第三个参数中的？提供响应的内容，这里我们的意思是给名字为李四的学生更新了数学成绩为65分。 五，删除数据 SQLiteDatabase提供了一个delete()方法用于删除数据，这个方法接收三个参数，第一个依旧为表名，第二三个参数用于约束某几行的数据，不指定则默认是删除所有行12SQLiteDatabase db=studentHelper.getWritableDatabase();db.delete(\"Student\",\"studentName=?\",new String[]&#123;\"李四\"&#125;); 和上面差不多，这里的意思是删除名为李四的学生的数据 五 查询数据 实际上，SQL数据库大部分的功能都是体现在查询上，由于查询功能的内容太多，这里只介绍Android上的查询功能,SQLiteDatabase提供了query()方法用于对数据进行查询，这个方法要传入七个参数，有点复杂。query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit) table：表名。相当于select语句from关键字后面的部分。如果是多表联合查询，可以用逗号将两个表名分开。 columns：要查询出来的列名。相当于select语句select关键字后面的部分。 selection：查询条件子句，相当于select语句where关键字后面的部分，在条件子句允许使用占位符“?” selectionArgs：对应于selection语句中占位符的值，值在数组中的位置与占位符在语句中的位置必须一致，否则就会有异常。 groupBy：相当于select语句group by关键字后面的部分 having：相当于select语句having关键字后面的部分 orderBy：相当于select语句order by关键字后面的部分，如：personid desc, age asc; limit：指定偏移量和获取的记录数，相当于select语句limit关键字后面的部分。 例子：1234567891011SQLiteDatabase db=studentHelper.getWritableDatabase();Cursor cursor=db.query(\"Student\",null,null,null,null,null,null);if(cursor.moveToFirst())&#123;//遍历Cursor对象do&#123;String studentID=cursor.getString(cursor.getColumnIndex(\"StudentID\"));String studentName=cursor.getString(cursor.getColumnIndex(\"studentName\"));int math=cursor.getString(cursor.getColumnIndex(\"math\"));&#125;(cursor.moveToNext());&#125;cursor.close(); 这里的query()非常简单，我们查询Student表的所有数据，得到了一个Cursor对象，然后我们调用它的moveToFirst()方法将数据指针指向第一行，然后进入循环遍历数据直到最后一行，最后调用close()方法关闭Cursor对象。","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"Android自定义View基础内容学习笔记(一)","date":"2016-11-28T11:43:10.000Z","path":"2016/11/28/2016-11-28/","text":"UI控件作为手机操作系统中的一部分，一直被很多开发者视为开发中最重要的一环，一个精简美观的UI界面可以极大的提高用户体验以达到软件设计目的。在Android中，Google已经为开发者提供了丰富的组件库来满足客户需求，但千篇一律的UI样式确实容易引起审美疲劳，于是自定义控件开始被广大开发者所关注。想设计一个好的自定义控件除了需要掌握必要额API知识外，也需要结合其它的绘图技巧，例如Photoshop等。本文将简略阐述自定义控件开发中的一些要点帮助我们日后更方便的理解开发自定义控件。 View定义了绘图的基本操作，因此自定义控件时需要继承View,通过View中的几个基本方法完成自定义控件。 1.onDraw() 自定义控件时，我们需要重写onDraw()方法绘制View内容，在View中onDraw()是一个空方法，因此我们需要覆写该方法同时加入自己的逻辑以实现该方法： 123456@Overrideprotected void onDraw(Canvas canvas)&#123;//绘制内容前super.onDraw(canvas);//绘制内容后&#125; 在该方法中，程序通过super.onDraw(canvas)方法来实现原生控件的功能，我们在该方法前写的逻辑将在加载控件前完成，之后同理，举个例子，我们自定义一个文字输入框，如果需要自定义输入框的样式，背景，则需要在super.onDraw(canvas)前写入响应的逻辑。如果我们需要给输入框内输入的文字添加动态样式等，则需要在super.onDraw(canvas)方法后写入逻辑，这部分很好理解。 2.onMeasure() 该方法用于对控件进行测量，说白了，控件的大小就是由这个方法控制，下面我们来看看该方法：1234567 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 通过逻辑计算所需要的长和宽 .... setMeasuredDimension(width,height); &#125; 首先我们看到这个方法需要传入的两个参数widthMeasureSpec和heightMeasureSpec，onMeasure()方法将被ViewGroup所调用，因此这两个参数也是从ViewGroup中传入，它们的作用是限制控件的大小。后面的setMeasuredDimension()方法同样需要传入两个参数，需要注意的是在这个方法中传入的参数是控件最终的大小，也就是说，在该方法前所有的逻辑都是为最后这两个函数所服务的，我们的目的就是在该方法中折腾出你所需要的width和height以确定空间大小。 3.onLayout() 前面两个函数已经决定了控件的绘图和大小，那么这个自然就是决定控件在ViewGroup所在的位置。在ViewGroup中，Layout的作用是确定整个页面View的位置，而如何确定位置则需要通过onLayout()方法去计算。确定位置的方法很好理解，只需要只需要mLeft，mTop，mRight，mBottom四个值(注意：这4个值是子View相对于父View的值) 123456protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; View view = getChildAt(i); //通过逻辑计算所需要的mLeft, mTop, mRight, mBottom。..... view.layout(mLeft, mTop, mRight, mBottom);&#125; 除了这三个基本方法外，也有其它比较重要的回调方法 onFinishInflate():从XML加载组件后回调onSizeChanged():组件大小改变时回调onMeasure():回调该方法进行测量onLayout():回调该方法确定显示的位置onTouchEvent():监听到触摸事件时回调 下面让我们写一个简单的自定义控件演示步骤(使用hongyang博客内容，谢谢)： 首先，我们需要在res目录下的values下创建文件attrs.xml，该文件用于定义控件的基本属性12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt;&lt;declare-styleable name=\"DIYView\"&gt; &lt;attr name=\"titleText\" format=\"string\" /&gt; &lt;attr name=\"titleTextColor\" format=\"color\" /&gt; &lt;attr name=\"titleTextSize\" format=\"dimension\" /&gt;&lt;/declare-styleable&gt;&lt;/resources&gt; 我们在代码中通过标签声明了使用自定义属性，在 标签声明了具体的自定义属性和名称，在这里我们定义了字体，颜色和字体大小三个属性然后开始构建代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class DiyView extends View &#123; private String mTitleText; private int mTitleTextColor; private int mTitleTextSize; //绘制时控制文本绘制的范围 private Rect mBound; private Paint mPaint; public DiyView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public DiyView(Context context) &#123; this(context, null); &#125; /** * 获得我自定义的样式属性 * * @param context * @param attrs * @param defStyle */ public DiyView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); /** * 获得我们所定义的自定义样式属性 */ TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.DIYView, defStyle, 0); int n = a.getIndexCount(); for (int i = 0; i &lt; n; i++) &#123; int attr = a.getIndex(i); switch (attr) &#123; case R.styleable.DIYView_titleText: mTitleText = a.getString(attr); break; case R.styleable.DIYView_titleTextColor: // 默认颜色设置为黑色 mTitleTextColor = a.getColor(attr, Color.BLACK); break; case R.styleable.DIYView_titleTextSize: // 默认设置为16sp，TypeValue也可以把sp转化为px mTitleTextSize = a.getDimensionPixelSize(attr, (int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics())); break; &#125; &#125; a.recycle(); /** * 获得绘制文本的宽和高 */ mPaint = new Paint(); mPaint.setTextSize(mTitleTextSize); // mPaint.setColor(mTitleTextColor); mBound = new Rect(); mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onDraw(Canvas canvas) &#123; mPaint.setColor(Color.YELLOW); canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint); mPaint.setColor(mTitleTextColor); canvas.drawText(mTitleText, getWidth() / 2 - mBound.width() / 2, getHeight() / 2 + mBound.height() / 2, mPaint); &#125;&#125; 然后，我们再将控件加入到布局中：123456&lt;com.palmintelligence.administrator.diyview.DiyView android:layout_width=\"100dp\" android:layout_height=\"100dp\" custom:titleText=\"popo1379\" custom:titleTextColor=\"#ff0000\" custom:titleTextSize=\"40sp\" /&gt; 除了自定义View外，也可以采用组合控件和继承控件的方法创建新的控件。","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"Android四大组件之Service(服务)基础知识（一）","date":"2016-11-23T13:28:16.000Z","path":"2016/11/23/2016-11-23/","text":"Service是Android实现程序后台运行的解决方案，它主要用于在后台处理一些耗时的逻辑，或者去执行某些需要长期运行的任务。服务的最大特点在于它不依赖于任何的用户界面，即使程序被切换到后台甚至在程序退出的情况下，Service依然能够保持正常运行。本文将对Service组件中常用的知识点进行探究，作为学习中的一次笔记，方便日后查看。 1，创建服务首先我们在项目中先新建一个名为MyService的类，该类继承自Service: 12345678910public class MyService extends Service &#123; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; &#125; 该服务中啥也没有，唯独一个onBind()方法，该方法是Service中唯一一个抽象方法，必须在子类中实现！onBind()方法针对的是Bound Service类型的Service，在Started Service类型中，此函数直接返回 null 即可。下面我们开始写一个完整的Service： 123456789101112131415161718192021222324252627282930public class MyService extends Service &#123; public static final String TAG = \"MyService\"; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.w(TAG, \"in onCreate\"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.w(TAG, \"in onStartCommand\"); Log.w(TAG, \"MyService:\" + this); String name = intent.getStringExtra(\"name\"); Log.w(TAG, \"name:\" + name); return START_STICKY; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.w(TAG, \"in onDestroy\"); &#125; &#125; 可以看到，这里我们又重写了onCreate(),onStartCommand(),onDestroy()方法，这是服务中最常使用的三个方法，其中，onCreate()方法只会在Service第一次被创建的时候调用，如果当前Service已经被创建过了，不管怎样调用startService()方法，onCreate()方法都不会再执行。而onStartCommand(Intent intent, int flags, int startId)方法会在每次服务启动时调用，其中，flags参数默认情况下为0，对应的常量名为START_STICKY_COMPATIBILITY。startId是一个唯一的整型，用于表示此次Client执行startService(…)的请求请求标识，在多次startService(…)的情况下，呈现0,1,2….递增。另外，此函数具有一个int型的返回值，具体的可选值及含义如下： START_NOT_STICKY：当Service因为内存不足而被系统kill后，接下来未来的某个时间内，即使系统内存足够可用，系统也不会尝试重新创建此Service。除非程序中Client明确再次调用startService(…)启动此Service。 START_STICKY：当Service因为内存不足而被系统kill后，接下来未来的某个时间内，当系统内存足够可用的情况下，系统将会尝试重新创建此Service，一旦创建成功后将回调onStartCommand(…)方法，但其中的Intent将是null，pendingintent除外。 START_REDELIVER_INTENT：与START_STICKY唯一不同的是，回调onStartCommand(…)方法时，其中的Intent将是非空，将是最后一次调用startService(…)中的intent。 START_STICKY_COMPATIBILITY：compatibility version of {@link #START_STICKY} that does not guarantee that {@link #onStartCommand} will be called again after being killed。此值一般不会使用，所以注意前面三种情形就好。 以上的描述中，”当Service因为内存不足而被系统kill后“一定要非常注意，因为此函数的返回值设定只是针对此种情况才有意义的，换言之，当认为的kill掉Service进程，此函数返回值无论怎么设定，接下来未来的某个时间内，即使系统内存足够可用，Service也不会重启。 onDestroy()方法会在销毁服务时调用。 因此，我们如果希望服务启动后立刻执行一个动作，可以将逻辑写在onStartCommand()中，而当服务销毁时，我们又应该在onDestroy()方法中回收相对应的资源。 写好服务类后，我们还需要在manifests.xml文件中对服务进行注册， 12 &lt;service android:name=\".MyService\"&gt;&lt;/service&gt; 这样，一个最简单的Service组件就OK了。 Service生命周期： Service的生命周期有两种创建途径，分别为started Service和bound Service started service 被开启的service通过其他组件调用 startService()被创建。 这种service可以无限地运行下去，必须调用stopSelf()方法或者其他组件调用stopService()方法来停止它。 当service被停止时，系统会销毁它。 bound service 被绑定的service是当其他组件（一个客户）调用bindService()来创建的。 客户可以通过一个IBinder接口和service进行通信。 客户可以通过 unbindService()方法来关闭这种连接。 一个service可以同时和多个客户绑定，一旦客户退出，Service将调用onUnbind()方法，即调用者与服务同生共死。 这二种方式是独立存在的，你可以在活动中对一个活动同时调用两种方法，但需要注意的是，当我们对一个服务同时调用两种方法后，必须要同时调用stopService()和unbindService()才会执行onDestroy()来销毁服务。二者缺一不可 那么，什么情况下既使用startService，又使用bindService呢？如果你只是想要启动一个后台服务长期进行某项任务，那么使用startService便可以了。如果你还想要与正在运行的Service取得联系，那么有两种方法：一种是使用broadcast，另一种是使用bindService。前者的缺点是如果交流较为频繁，容易造成性能上的问题，而后者则没有这些问题。因此，这种情况就需要startService和bindService一起使用了。 后面的文章中我们将用实战来对服务内容进行具体讲解。","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"开发实录：Android异步加载图片神器Universal-Image-Loader开源框架初次使用报告","date":"2016-11-16T08:03:17.000Z","path":"2016/11/16/2016-11-16/","text":"前端时间写APP时候有一个要实现简单新闻功能的需求，其它都好说，到百度API商店找个免费的URL搞到APP里就OK，唯独这个新闻图片不好处理，因为要异步加载，还要涉及到图片尺寸大小等等各种设置，如果自己写代码对于我这个新手可能折腾两周也搞不出来，于是在学长的推荐下开始使用Universal-Image-Loader开源框架，因为只是简单的把图片显示出来，基本没难度，这次写出来，以后有需求再回来看看。一下是大牛们总结的特效： 1.多线程下载图片，图片可以来源于网络，文件系统，项目文件夹assets中以及drawable中等2.支持随意的配置ImageLoader，例如线程池，图片下载器，内存缓存策略，硬盘缓存策略，图片显示选项以及其他的一些配置3.支持图片的内存缓存，文件系统缓存或者SD卡缓存4.支持图片下载过程的监听5.根据控件(ImageView)的大小对Bitmap进行裁剪，减少Bitmap占用过多的内存6.较好的控制图片的加载过程，例如暂停图片加载，重新开始加载图片，一般使用在ListView,GridView中，滑动过程中暂停加载图片，停止滑动的时候去加载图片7.提供在较慢的网络下对图片进行加载 准备工作：1.下载Universal-Image-Loader，添加到libs目录下 manifests添加下列代码：1234&lt;!-- 写入扩展存储，向扩展卡写入数据，用于写入离线定位数据--&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt; &lt;!-- 访问网络，网络定位需要上网--&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; OK，开始写代码了 首先新建MyApplication继承Application12345678910111213141516171819202122232425262728293031public class MyApplication extends Application &#123; @Override public void onCreate() &#123; // TODO 您的其他初始化流程 initImageLoader(getApplicationContext()); super.onCreate(); &#125; public static void initImageLoader(Context context) &#123; ImageLoaderConfiguration config = new ImageLoaderConfiguration .Builder(context) .memoryCacheExtraOptions(100, 100) // max width, max height，即保存的每个缓存文件的最大长宽 .threadPoolSize(5)//线程池内加载的数量 .threadPriority(Thread.NORM_PRIORITY - 2) .denyCacheImageMultipleSizesInMemory() .memoryCache(new UsingFreqLimitedMemoryCache(2 * 1024 * 1024)) // You can pass your own memory cache implementation/你可以通过自己的内存缓存实现 .memoryCacheSize(2 * 1024 * 1024) .discCacheSize(50 * 1024 * 1024) .discCacheFileNameGenerator(new Md5FileNameGenerator())//将保存的时候的URI名称用MD5 加密 .tasksProcessingOrder(QueueProcessingType.LIFO) .discCacheFileCount(100) //缓存的文件数 .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) .imageDownloader(new BaseImageDownloader(context, 20* 1000, 60 * 1000)) // connectTimeout (5 s), readTimeout (30 s)超时时间 .writeDebugLogs() // Remove for release app .build();//开始构建 // Initialize ImageLoader with configuration. ImageLoader.getInstance().init(config); &#125;&#125; 在MyApplication中，我们可以进行框架的设置，我们在项目中不需要每一个都自己设置，一般使用createDefault()创建的ImageLoaderConfiguration就能使用，然后调用ImageLoader的init（）方法将ImageLoaderConfiguration参数传递进去，ImageLoader使用单例模式。 下面，我们就可以在项目代码里使用框架咯 我们在准备好解析错误显示时的提示图片，图片所需的imageUrl和相关的控件后，开始设置options（DisplayImageOptions配置信息） 123456789options = new DisplayImageOptions.Builder() .showImageOnLoading(R.drawable.newspic_loading) // 设置图片下载期间显示的图片 .showImageForEmptyUri(R.drawable.newspic_emptyuri) // 设置图片Uri为空或是错误的时候显示的图片 .showImageOnFail(R.drawable.newspic_fail) // 设置图片加载或解码过程中发生错误显示的图片 .cacheInMemory(true) // 设置下载的图片是否缓存在内存中 .cacheOnDisk(true) // 设置下载的图片是否缓存在SD卡中 // .displayer(new RoundedBitmapDisplayer(10)) // 设置成圆角图片 .build(); // 构建完成 显示图片： 1ImageLoader.getInstance().displayImage(uri, imageView, options); 三个参数分别是图片URL地址，imageView控件，设置。 这样，我们就可以异步加载网络图片了。 项目代码：1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/news_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/swipRefresh\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:padding=\"10dp\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/news_RV_list\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"120dp\" android:layout_marginBottom=\"2dp\" android:layout_marginLeft=\"5dp\" android:layout_marginRight=\"5dp\" android:layout_marginTop=\"2dp\" app:cardCornerRadius=\"5dp\" app:elevation=\"1dp\"&gt; &lt;LinearLayout android:id=\"@+id/news_swipe_item_container\" android:layout_width=\"match_parent\" android:layout_height=\"174dp\" android:orientation=\"horizontal\" android:padding=\"5dp\"&gt; &lt;TextView android:id=\"@+id/news_swipe_item_title\" android:layout_width=\"0dp\" android:layout_height=\"104dp\" android:layout_weight=\"1\" android:gravity=\"left|center_vertical\" android:textSize=\"21sp\" android:layout_gravity=\"center_vertical|right\" /&gt; &lt;ImageView android:id=\"@+id/news_swipe_item_icon\" android:layout_width=\"90dp\" android:layout_height=\"90dp\" android:layout_gravity=\"center_vertical|right\" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/news_title_time\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"2016_1_1\" android:textSize=\"20dp\"/&gt;&lt;/android.support.v7.widget.CardView&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169public class NewsActivity extends AppCompatActivity &#123; private RecyclerView mRecyclerView; private List&lt;News&gt; mdatas=new ArrayList&lt;News&gt;();private String time_0,title_0,picUrl_0,url_0,time_1,title_1,picUrl_1,url_1,time_2,title_2,picUrl_2,url_2,time_3,title_3,picUrl_3,url_3,time_4,title_4,picUrl_4,url_4,time_5,title_5,picUrl_5,url_5,time_6,title_6,picUrl_6,url_6,time_7,title_7,picUrl_7,url_7; private SwipeRefreshLayout swipeRefreshLayout; protected ImageLoader imageLoader = ImageLoader.getInstance(); private DisplayImageOptions options; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.news_layout); initUI(); News new0=new News(time_0,title_0,picUrl_0); News new1=new News(time_1,title_1,picUrl_1); News new2=new News(time_2,title_2,picUrl_2); News new3=new News(time_3,title_3,picUrl_3); News new4=new News(time_4,title_4,picUrl_5); News new5=new News(time_5,title_5,picUrl_5); News new6=new News(time_6,title_6,picUrl_6); News new7=new News(time_7,title_7,picUrl_7); mdatas.add(new0); mdatas.add(new1); mdatas.add(new2); mdatas.add(new3); mdatas.add(new4); mdatas.add(new5); mdatas.add(new6); mdatas.add(new7); NewsAdapter mAdapter=new NewsAdapter(NewsActivity.this, mdatas); mRecyclerView.setAdapter(mAdapter); swipeRefreshLayout=(SwipeRefreshLayout)findViewById(R.id.swipRefresh); //改变加载显示的颜色 swipeRefreshLayout.setColorSchemeColors(R.color.swipe_color_1,R.color.swipe_color_2); //设置初始时的大小 swipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE); //设置向下拉多少出现刷新 swipeRefreshLayout.setDistanceToTriggerSync(100); //设置刷新出现的位置 swipeRefreshLayout.setProgressViewEndTarget(false, 200); //设置监听 swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; mdatas.clear(); News new0 = new News(time_0, title_0, picUrl_0); News new1 = new News(time_1, title_1, picUrl_1); News new2 = new News(time_2, title_2, picUrl_2); News new3 = new News(time_3, title_3, picUrl_3); News new4 = new News(time_4, title_4, picUrl_5); News new5 = new News(time_5, title_5, picUrl_5); News new6 = new News(time_6, title_6, picUrl_6); News new7 = new News(time_7, title_7, picUrl_7); mdatas.add(new0); mdatas.add(new1); mdatas.add(new2); mdatas.add(new3); mdatas.add(new4); mdatas.add(new5); mdatas.add(new6); mdatas.add(new7); swipeRefreshLayout.setRefreshing(false); &#125; &#125;); //Toolbar设置 android.support.v7.widget.Toolbar traffic_toolbar=(android.support.v7.widget.Toolbar) findViewById(R.id.news_toolbar); traffic_toolbar.setTitle(\"校园新闻(仅演示功能)\"); // traffic_toolbar.setNavigationIcon(android.R.id.home); setSupportActionBar(traffic_toolbar); traffic_toolbar.setNavigationIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha); traffic_toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onBackPressed(); &#125; &#125;); &#125; private void initUI()&#123; mRecyclerView=(RecyclerView)findViewById(R.id.news_RV_list); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); apiTest();&#125; private void apiTest() &#123; Parameters para = new Parameters(); para.put(\"num\", \"10\"); ApiStoreSDK.execute(\"http://apis.baidu.com/txapi/social/social\", ApiStoreSDK.GET, para, new ApiCallBack() &#123; @Override public void onSuccess(int status, String responseString) &#123; Log.i(\"sdkdemo\", \"onSuccess\"); NewsUtility.handleNewsResponse(NewsActivity.this,responseString); &#125; &#125;); showNews(); &#125;private void showNews()&#123; SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this); time_0=prefs.getString(\"time_0\",\"\"); title_0=prefs.getString(\"title_0\",\"\"); picUrl_0=prefs.getString(\"picUrl_0\",\"\"); url_0=prefs.getString(\"url_0\",\"\"); time_1=prefs.getString(\"time_1\",\"\"); title_1=prefs.getString(\"title_1\",\"\"); picUrl_1=prefs.getString(\"picUrl_1\",\"\"); url_1=prefs.getString(\"url_1\",\"\"); time_2=prefs.getString(\"time_2\",\"\"); title_2=prefs.getString(\"title_2\",\"\"); picUrl_2=prefs.getString(\"picUrl_2\",\"\"); url_2=prefs.getString(\"url_2\",\"\"); time_3=prefs.getString(\"time_3\",\"\"); title_3=prefs.getString(\"title_3\",\"\"); picUrl_3=prefs.getString(\"picUrl_3\",\"\"); url_3=prefs.getString(\"url_3\",\"\"); time_4=prefs.getString(\"time_4\",\"\"); title_4=prefs.getString(\"title_4\",\"\"); picUrl_4=prefs.getString(\"picUrl_4\",\"\"); url_4=prefs.getString(\"url_4\",\"\"); time_5=prefs.getString(\"time_5\",\"\"); title_5=prefs.getString(\"title_5\",\"\"); picUrl_5=prefs.getString(\"picUrl_5\",\"\"); url_5=prefs.getString(\"url_5\",\"\"); time_6=prefs.getString(\"time_6\",\"\"); title_6=prefs.getString(\"title_6\",\"\"); picUrl_6=prefs.getString(\"picUrl_6\",\"\"); url_6=prefs.getString(\"url_6\",\"\"); time_7=prefs.getString(\"time_7\",\"\"); title_7=prefs.getString(\"title_7\",\"\"); picUrl_7=prefs.getString(\"picUrl_7\",\"\"); url_7=prefs.getString(\"url_7\",\"\");&#125;&#125; 12345678910111213141516public class News &#123; private String news_title; private String news_pic; private String news_time; public News(String time,String title,String pic)&#123; news_time=time; news_title=title; news_pic=pic; &#125; public String getNews_time()&#123;return news_time;&#125; public String getTitle()&#123;return news_title;&#125; public String getNews_pic()&#123;return news_pic;&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class NewsUtility &#123; public static void handleNewsResponse(Context context, String response) &#123; try &#123; JSONObject jsonObject = new JSONObject(response); JSONArray jsonArray_newslist = jsonObject.getJSONArray(\"newslist\"); JSONObject jsonNews_0 = (JSONObject) jsonArray_newslist.get(0); String news_0_ctime = jsonNews_0.getString(\"ctime\"); String news_0_title = jsonNews_0.getString(\"title\"); String news_0_picUrl = jsonNews_0.getString(\"picUrl\"); String news_0_Url = jsonNews_0.getString(\"url\"); JSONObject jsonNews_1 = (JSONObject) jsonArray_newslist.get(1); String news_1_ctime = jsonNews_1.getString(\"ctime\"); String news_1_title = jsonNews_1.getString(\"title\"); String news_1_picUrl = jsonNews_1.getString(\"picUrl\"); String news_1_Url = jsonNews_1.getString(\"url\"); JSONObject jsonNews_2 = (JSONObject) jsonArray_newslist.get(2); String news_2_ctime = jsonNews_2.getString(\"ctime\"); String news_2_title = jsonNews_2.getString(\"title\"); String news_2_picUrl = jsonNews_2.getString(\"picUrl\"); String news_2_Url = jsonNews_2.getString(\"url\"); JSONObject jsonNews_3 = (JSONObject) jsonArray_newslist.get(3); String news_3_ctime = jsonNews_3.getString(\"ctime\"); String news_3_title = jsonNews_3.getString(\"title\"); String news_3_picUrl = jsonNews_3.getString(\"picUrl\"); String news_3_Url = jsonNews_3.getString(\"url\"); JSONObject jsonNews_4 = (JSONObject) jsonArray_newslist.get(4); String news_4_ctime = jsonNews_4.getString(\"ctime\"); String news_4_title = jsonNews_4.getString(\"title\"); String news_4_picUrl = jsonNews_4.getString(\"picUrl\"); String news_4_Url = jsonNews_4.getString(\"url\"); JSONObject jsonNews_5 = (JSONObject) jsonArray_newslist.get(5); String news_5_ctime = jsonNews_5.getString(\"ctime\"); String news_5_title = jsonNews_5.getString(\"title\"); String news_5_picUrl = jsonNews_5.getString(\"picUrl\"); String news_5_Url = jsonNews_5.getString(\"url\"); JSONObject jsonNews_6 = (JSONObject) jsonArray_newslist.get(6); String news_6_ctime = jsonNews_6.getString(\"ctime\"); String news_6_title = jsonNews_6.getString(\"title\"); String news_6_picUrl = jsonNews_6.getString(\"picUrl\"); String news_6_Url = jsonNews_6.getString(\"url\"); JSONObject jsonNews_7 = (JSONObject) jsonArray_newslist.get(7); String news_7_ctime = jsonNews_7.getString(\"ctime\"); String news_7_title = jsonNews_7.getString(\"title\"); String news_7_picUrl = jsonNews_7.getString(\"picUrl\"); String news_7_Url = jsonNews_7.getString(\"url\"); saveNewsinfo(context, news_0_ctime, news_0_title, news_0_picUrl, news_0_Url, news_1_ctime,news_1_title,news_1_picUrl,news_1_Url, news_2_ctime,news_2_title,news_2_picUrl,news_2_Url, news_3_ctime,news_3_title,news_3_picUrl,news_3_Url, news_4_ctime,news_4_title,news_4_picUrl,news_4_Url, news_5_ctime,news_5_title,news_5_picUrl,news_5_Url, news_6_ctime,news_6_title,news_6_picUrl,news_6_Url, news_7_ctime,news_7_title,news_7_picUrl,news_7_Url); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; public static void saveNewsinfo(Context context, String time_0, String title_0, String picUrl_0, String url_0, String time_1, String title_1, String picUrl_1, String url_1, String time_2, String title_2, String picUrl_2, String url_2, String time_3, String title_3, String picUrl_3, String url_3, String time_4, String title_4, String picUrl_4, String url_4, String time_5, String title_5, String picUrl_5, String url_5, String time_6, String title_6, String picUrl_6, String url_6, String time_7, String title_7, String picUrl_7, String url_7) &#123; SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit();editor.putString(\"time_0\",time_0); editor.putString(\"title_0\",title_0); editor.putString(\"picUrl_0\",picUrl_0); editor.putString(\"url_0\",url_0); editor.putString(\"time_1\",time_1); editor.putString(\"title_1\",title_1); editor.putString(\"picUrl_1\",picUrl_1); editor.putString(\"url_1\",url_1); editor.putString(\"time_2\",time_2); editor.putString(\"title_2\",title_2); editor.putString(\"picUrl_2\",picUrl_2); editor.putString(\"url_2\",url_2); editor.putString(\"time_3\",time_3); editor.putString(\"title_3\",title_3); editor.putString(\"picUrl_3\",picUrl_3); editor.putString(\"url_3\",url_3); editor.putString(\"time_4\",time_4); editor.putString(\"title_4\",title_4); editor.putString(\"picUrl_4\",picUrl_4); editor.putString(\"url_4\",url_4); editor.putString(\"time_5\",time_5); editor.putString(\"title_5\",title_5); editor.putString(\"picUrl_5\",picUrl_5); editor.putString(\"url_5\",url_5); editor.putString(\"time_6\",time_6); editor.putString(\"title_6\",title_6); editor.putString(\"picUrl_6\",picUrl_6); editor.putString(\"url_6\",url_6); editor.putString(\"time_7\",time_7); editor.putString(\"title_7\",title_7); editor.putString(\"picUrl_7\",picUrl_7); editor.putString(\"url_7\",url_7); editor.commit(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class NewsAdapter extends RecyclerView.Adapter&lt;NewsAdapter.NormalItemHolder&gt; &#123; protected ImageLoader imageLoader = ImageLoader.getInstance(); private DisplayImageOptions options; private Context mContext; private List&lt;News&gt; mDataList; private LayoutInflater mLayoutInflater; private News news; public NewsAdapter(Context mContext1, List&lt;News&gt; mDataList1) &#123; mContext = mContext1; mDataList = mDataList1; mLayoutInflater = LayoutInflater.from(mContext); &#125; //这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。 @Override public NormalItemHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123; View view = mLayoutInflater.inflate(R.layout.news_item,viewGroup, false); NormalItemHolder holder= new NormalItemHolder(view); return holder; &#125; // 这个方法主要用于适配渲染数据到View中。 @Override public void onBindViewHolder(NormalItemHolder viewHolder,int position) &#123; news= mDataList.get(position); if (null == news) return;else &#123; viewHolder.newsTime.setText(news.getNews_time()); viewHolder.newsTitle.setText(news.getTitle()); // 使用DisplayImageOptions.Builder()创建DisplayImageOptions options = new DisplayImageOptions.Builder() .showImageOnLoading(R.drawable.newspic_loading) // 设置图片下载期间显示的图片 .showImageForEmptyUri(R.drawable.newspic_emptyuri) // 设置图片Uri为空或是错误的时候显示的图片 .showImageOnFail(R.drawable.newspic_fail) // 设置图片加载或解码过程中发生错误显示的图片 .cacheInMemory(true) // 设置下载的图片是否缓存在内存中 .cacheOnDisk(true) // 设置下载的图片是否缓存在SD卡中 // .displayer(new RoundedBitmapDisplayer(10)) // 设置成圆角图片 .build(); // 构建完成 ImageLoader.getInstance().displayImage(news.getNews_pic(),viewHolder.newsIcon,options); &#125; &#125; //得到所需Item数量 @Override public int getItemCount() &#123; return mDataList.size(); &#125; public class NormalItemHolder extends RecyclerView.ViewHolder &#123; TextView newsTitle,newsTime; ImageView newsIcon; public NormalItemHolder(View itemView) &#123; super(itemView); newsTime=(TextView)itemView.findViewById(R.id.news_title_time); newsTitle = (TextView) itemView.findViewById(R.id.news_swipe_item_title); newsIcon = (ImageView) itemView.findViewById(R.id.news_swipe_item_icon); itemView.findViewById(R.id.news_swipe_item_container).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125; &#125;); &#125; &#125;&#125;","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"『持续更新』Android Layout：XML各布局常用属性大杂烩","date":"2016-11-06T03:25:01.000Z","path":"2016/11/06/2016-11-6/","text":"本文结合网上大牛们的资料，记录在Android开发中各个布局的常用属性，增强记忆，日后忘记了还能看看。 relativelayout布局（相对布局）：android:layout_above 将该控件的底部至于给定ID的控件之上android:layout_below 将该控件的顶部至于给定ID的控件之下android:layout_toLeftOf 将该控件的右边缘和给定ID的控件的左边缘对齐android:layout_toRightOf 将该控件的左边缘和给定ID的控件的右边缘对齐 android:layout_alignBaseline 该控件的baseline和给定ID的控件的baseline对齐android:layout_alignBottom 将该控件的底部边缘与给定ID控件的底部边缘对齐android:layout_alignLeft 将该控件的左边缘与给定ID控件的左边缘对齐android:layout_alignRight 将该控件的右边缘与给定ID控件的右边缘对齐android:layout_alignTop 将给定控件的顶部边缘与给定ID控件的顶部对齐 android:alignParentBottom 如果该值为true，则将该控件的底部和父控件的底部对齐android:layout_alignParentLeft 如果该值为true，则将该控件的左边与父控件的左边对齐android:layout_alignParentRight 如果该值为true，则将该控件的右边与父控件的右边对齐android:layout_alignParentTop 如果该值为true，则将空间的顶部与父控件的顶部对齐 android:layout_centerHorizontal 如果值为真，该控件将被至于水平方向的中央android:layout_centerInParent 如果值为真，该控件将被至于父控件水平方向和垂直方向的中央android:layout_centerVertical 如果值为真，该控件将被至于垂直方向的中央 ========================================================================================== LinearLayout布局（线性布局）： android:orientation决定是水平排列或是垂直排列vertical 垂直排列horizontal 水平排列 android:gravity设定框架的内容的放置方向center 水平垂直皆置中center_vertical 垂直置中center_horizontal 水平置中top 置顶left 置左bottom 置底right 置右 android:layout_weight子元件或子框架的比重。LinearLayout 下的子元件或子框架，才能设定这项属性。当所有控件的值都设为1时，大小全部相同。 android:layout_alignParentBottom=”true” alignparentbottom：是否显示在容器底部。 值为true 或者 false ================================================================================================ 其它常用属性： background会根据ImageView组件给定的长宽进行拉伸，而src就存放的是原图的大小，不会进行拉伸。src是图片内容（前景），bg是背景，可以同时使用。此外：scaleType只对src起作用；bg可设置透明度，比如在ImageButton中就可以用Android:scaleType控制图片的缩放方式。scaleType常用属性：CENTER /center 在视图中心显示图片，并且不缩放图片 CENTER_CROP / centerCrop 按比例缩放图片，使得图片长 (宽)的大于等于视图的相应维度 CENTER_INSIDE / centerInside 按比例缩放图片，使得图片长 (宽)的小于等于视图的相应维度 FIT_CENTER / fitCenter 按比例缩放图片到视图的最小边，居中显示 FIT_END / fitEnd 按比例缩放图片到视图的最小边，显示在视图的下部分位置 FIT_START / fitStart 把图片按比例扩大/缩小到视图的最小边，显示在视图的上部分位置 FIT_XY / fitXY 把图片不按比例缩放到视图的大小显示 MATRIX / matrix 用矩阵来绘制 ==========================================================================================EditText的android:hint 设置EditText为空时输入框内的提示信息。 android:gravity android:gravity属性是对该view 内容的限定．比如一个button 上面的text. 你可以设置该text 在view的靠左，靠右等位置．以button为例，android:gravity=”right”则button上面的文字靠右 android:layout_gravityandroid:layout_gravity是用来设置该view相对与起父view 的位置．比如一个button 在linearlayout里，你想把该button放在靠左、靠右等位置就可以通过该属性设置．以button为例，android:layout_gravity=”right”则button靠右 android:layout_alignParentRight使当前控件的右端和父控件的右端对齐。这里属性值只能为true或false，默认false。 layout_margin就是设置view的上下左右边框的额外空间 android:padding是设置内容相对view的边框的距离 未完待续","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"Android开发：RecyclerView实现简单瀑布流效果","date":"2016-11-04T09:46:15.000Z","path":"2016/11/04/2016-11-4/","text":"RecyclerView是谷歌随着Android 5.0推出的全新控件，RecyclerView提供了一种拔插式的体验，相较于它的前代ListView具有低耦合，扩展性强的特点，现在越来越多的开发者放弃listView转而使用RecyclerView，RecyclerView控件也可以实现更多更强大的功能，瀑布流就是其中的一种。 前段时间想用listview实现一个非常简单电话薄功能，后来发现用瀑布流更美观更显目，完成后把代码发上来，就当一篇加深印象的学习笔记，日后有需求还可以来看看。 想要实现RecyclerView功能，首先要在Gradle中添加依赖包：1compile 'com.android.support:recyclerview-v7:+' 同时为了更美观的实现瀑布流效果，我们使用了cardview作为控件中的item添加依赖包：1compile 'com.android.support:cardview-v7:21.0.3' 如果你熟悉listview,那么RecyclerView上手一样简单，在布局上基本和listview相同： 123456&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/tellbook_rv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scrollbars=\"vertical\" &gt; 子布局：1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:card_view=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.CardView android:id=\"@+id/card_view\" android:layout_gravity=\"center\" android:layout_width=\"150dp\" android:layout_height=\"wrap_content\" card_view:cardUseCompatPadding=\"true\" card_view:cardCornerRadius=\"10dp\" card_view:cardBackgroundColor=\"#FF9900\" &gt;&lt;TextView android:id=\"@+id/tellbook_name\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"20sp\" android:gravity=\"center\" /&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/LinearLayout&gt; 代码部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TellBookActivity extends AppCompatActivity &#123; private List&lt;String&gt;tellBooklist=new ArrayList&lt;String&gt;(); @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.tellbook_layout); //初始化数据 initTellbook(); //设置RecyclerView RecyclerView tellbook_RV=(RecyclerView)findViewById(R.id.tellbook_rv); //固定控件大小提高性能 tellbook_RV.setHasFixedSize(true); //数据传入构造器 TellbookAdapter adapter=new TellbookAdapter(TellBookActivity.this,tellBooklist); //组合配适器 tellbook_RV.setAdapter(adapter); //设置布局管理器 //列数为两列 int spanCount = 3; //设置布局为瀑布流 StaggeredGridLayoutManager mLayoutManager = new StaggeredGridLayoutManager( spanCount, StaggeredGridLayoutManager.VERTICAL); tellbook_RV.setLayoutManager(mLayoutManager); //设置Toolbar Toolbar tellbook_toolbar=(Toolbar)findViewById(R.id.tellbook_toolbar); tellbook_toolbar.setTitle(\"化工学院各办公室电话查询(仅演示功能)\"); setSupportActionBar(tellbook_toolbar); tellbook_toolbar.setNavigationIcon(R.drawable.abc_ic_ab_back_mtrl_am_alpha); tellbook_toolbar.setNavigationOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v) &#123; onBackPressed(); &#125; &#125;);&#125;private void initTellbook()&#123; String number1=new String(\"党委办公室、校长办公室：63083027\"); tellBooklist.add(number1); String number2=new String(\"招生电话：本(专)科生:0432-63083056\"); tellBooklist.add(number2); String number3=new String(\"研究生:0432-63081060\"); tellBooklist.add(number3); String number4=new String (\"图书馆：63083149\"); tellBooklist.add(number4 );&#125;&#125; 配适器：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TellbookAdapter extends RecyclerView.Adapter&lt;TellbookAdapter.MyViewHolder&gt;&#123; private List&lt;String&gt; mDatas; private Context mContext; private LayoutInflater inflater; public TellbookAdapter(Context context, List&lt;String&gt; datas)&#123; this.mContext=context; this.mDatas=datas; inflater=LayoutInflater.from(mContext); &#125; //得到所需Item数量 @Override public int getItemCount() &#123; return mDatas.size(); &#125;//这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。 public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = inflater.inflate(R.layout.tellbook_item,parent, false); MyViewHolder holder= new MyViewHolder(view); return holder; &#125; // 这个方法主要用于适配渲染数据到View中。 @Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; holder.tv.setText( mDatas.get(position)); //设置瀑布流高度 holder.tv.setHeight(200 + (position % 3) * 100); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView tv; public MyViewHolder(View view) &#123; super(view); tv = (TextView) view.findViewById(R.id.tellbook_name); &#125; &#125;&#125;","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"Android开发之实现带小圆点的ViewPager导航","date":"2016-10-27T04:40:08.000Z","path":"2016/10/27/2016-10-27/","text":"在Android开发的实际过程中，我们经常需要在APP首页顶部做出一个可以滑动，并有导航功能的图片滑动功能做信息检索，例如网易新闻等APP，相对于其它平台，实现Android的导航功能比较复杂，目前Goolge还没有发布一款官方的控件支持这一功能，不过程序是死的，人是活的，我们依旧可以利用现有控件实现这一功能。 下面是我最近写的一款简易播放器界面： 现将功能实现代码贴上：布局：1234567891011121314151617&lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"150dp\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/banner_viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"160dp\"/&gt; &lt;LinearLayout android:id=\"@+id/banner_viewpager_points\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" android:orientation=\"horizontal\"/&gt; &lt;/RelativeLayout&gt; 可以看到，在布局文件中，我们需要用ViewPager作为框架，内部放入LinearLayout作为小圆点的界面小圆点drawable代码：12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_enabled=\"true\"&gt; &lt;shape android:shape=\"oval\"&gt; &lt;size android:width=\"7dp\" android:height=\"7dp\"/&gt; &lt;solid android:color=\"@color/base_color\"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:state_enabled=\"false\"&gt; &lt;shape android:shape=\"oval\"&gt; &lt;size android:width=\"7dp\" android:height=\"7dp\"/&gt; &lt;solid android:color=\"#77ffffff\"/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; 将以上代码新建至drawable文件夹中，作为小圆点图片资源 后台代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MainActivity extends AppCompatActivity &#123; private ViewPager mViewPager; private ArrayList&lt;View&gt; mViewpages; //导航圆点图片 private ImageView mImageView; //导航圆点数组 private ImageView[] imageViews; // 包裹小圆点的LinearLayout private LinearLayout mPoints; private int lastPosition; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mViewPager=(ViewPager)findViewById(R.id.banner_viewpager); mPoints=(LinearLayout)findViewById(R.id.banner_viewpager_points); //将图片装入ViewPager: int [] img=new int[]&#123;R.drawable.main_viewpager_pic1,R.drawable.main_viewpager_pic2,R.drawable.main_viewpager_pic3, R.drawable.main_viewpager_pic4,R.drawable.main_viewpager_pic5&#125;; mViewpages=new ArrayList&lt;View&gt;(); for(int i=0;i&lt;img.length;i++) &#123; LinearLayout linearLayout = new LinearLayout(MainActivity.this); LinearLayout.LayoutParams ltp = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); final ImageView imageView = new ImageView(MainActivity.this); //将图片的内容完整居中显示，通过按比例缩小或原来的size使得图片长/宽等于或小于View的长/宽 imageView.setScaleType(ImageView.ScaleType.CENTER_INSIDE); //动态设置图片显示 imageView.setImageResource(img[i]); //绑定小圆点 linearLayout.addView(imageView, ltp); //将资源加入到Viewpager中 mViewpages.add(linearLayout); &#125; mViewPager.setAdapter(new MainViewpagerAdapter(mViewpages)); mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override // onPageSelected方法是页面跳转完后得到调用,position为位置编号。 public void onPageSelected(int position) &#123; // 控制底部导航点的显示 position %= mViewpages.size(); mPoints.getChildAt(position).setEnabled(true); mPoints.getChildAt(lastPosition).setEnabled(false); lastPosition = position; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;);/** * 动态加载指示点 */ imageViews=new ImageView[mViewpages.size()]; for (int i=0;i&lt;mViewpages.size();i++) &#123; LinearLayout.LayoutParams margin = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); mImageView = new ImageView(MainActivity.this); mImageView.setBackgroundResource(R.drawable.viewpager_point); imageViews[i] = mImageView; // 设置每个小圆点距离左边的间距 margin.setMargins(10, 0, 0, 0); mImageView.setLayoutParams(margin); if (i == 0) &#123; mImageView.setEnabled(true); &#125; else &#123; mImageView.setEnabled(false); &#125; mPoints.addView(mImageView); &#125; &#125; &#125; ViewPager适配器： 123456789101112131415161718192021222324252627282930public class MainViewpagerAdapter extends PagerAdapter &#123; private ArrayList&lt;View&gt; mViewpagees; public MainViewpagerAdapter(ArrayList&lt;View&gt; mViewpages) &#123; this.mViewpagees = mViewpages; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; View view = mViewpagees.get(position % mViewpagees.size()); container.addView(view); return view; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView((View) object); &#125; @Override public int getCount() &#123; return Integer.MAX_VALUE; &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; &#125;","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"android开发之JSON数据格式解析实际案例","date":"2016-10-22T09:00:13.000Z","path":"2016/10/22/2016-10-22/","text":"JSON百科：JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。 在Android开发过程中，我们经常需要和服务器进行数据交互，目前常用的交互格式有两种，XML以及JSON,在android开发中大部分交互都使用JSON，因为JSON具有小，轻，快的特点，适合移动互联网传递数据，本文将用实际开发案例对JSON使用方法进行解析。 实际上，android平台对JSON是很友好的，google已经提供了相关的API可以让我们轻松提取数据流中的信息。 Android的JSON解析部分都在包org.json下，主要有以下几个类：JSONObject：可以看作是一个json对象,这是系统中有关JSON定义的基本单元，其包含一对儿(Key/Value)数值。它对外部(External：应用toString()方法输出的数值)调用的响应体现为一个标准的字符串（例如：{“JSON”: “Hello, World”}，最外被大括号包裹，其中的Key和Value被冒号”:”分隔）。其对于内部(Internal)行为的操作格式略微，例如：初始化一个JSONObject实例，引用内部的put()方法添加数值：new JSONObject().put(“JSON”, “Hello, World!”)，在Key和Value之间是以逗号”,”分隔。Value的类型包括：Boolean、JSONArray、JSONObject、Number、String或者默认值JSONObject.NULL object。 JSONStringer：json文本构建类 ，根据官方的解释，这个类可以帮助快速和便捷的创建JSON text。其最大的优点在于可以减少由于 格式的错误导致程序异常，引用这个类可以自动严格按照JSON语法规则（syntax rules）创建JSON text。每个JSONStringer实体只能对应创建一个JSON text。。其最大的优点在于可以减少由于格式的错误导致程序异常，引用这个类可以自动严格按照JSON语法规则（syntax rules）创建JSON text。每个JSONStringer实体只能对应创建一个JSON text。 JSONArray：它代表一组有序的数值。将其转换为String输出(toString)所表现的形式是用方括号包裹，数值以逗号”,”分隔（例如：[value1,value2,value3]，大家可以亲自利用简短的代码更加直观的了解其格式）。这个类的内部同样具有查询行为，get()和opt()两种方法都可以通过index索引返回指定的数值，put()方法用来添加或者替换数值。同样这个类的value类型可以包括：Boolean、JSONArray、JSONObject、Number、String或者默认值JSONObject.NULL object。JSONTokener：json解析类JSONException：json中用到的异常 下面让我们看看具体代码案例为大家演示JSON格式数据解析这个Demo中直接使用了百度API应用商店中的免费天气预报，个人觉得百度这个商店搞的还是可以的，有官方的SDK简化调用API，适合快速开发返回JSON数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304&#123; \"HeWeather data service 3.0\": [ &#123; \"aqi\": &#123; \"city\": &#123; \"aqi\": \"15\", \"co\": \"0\", \"no2\": \"20\", \"o3\": \"40\", \"pm10\": \"15\", \"pm25\": \"14\", \"qlty\": \"优\", \"so2\": \"2\" &#125; &#125;, \"basic\": &#123; \"city\": \"北京\", \"cnty\": \"中国\", \"id\": \"CN101010100\", \"lat\": \"39.904000\", \"lon\": \"116.391000\", \"update\": &#123; \"loc\": \"2016-10-22 17:04\", \"utc\": \"2016-10-22 09:04\" &#125; &#125;, \"daily_forecast\": [ &#123; \"astro\": &#123; \"sr\": \"06:32\", \"ss\": \"17:25\" &#125;, \"cond\": &#123; \"code_d\": \"101\", \"code_n\": \"101\", \"txt_d\": \"多云\", \"txt_n\": \"多云\" &#125;, \"date\": \"2016-10-22\", \"hum\": \"67\", \"pcpn\": \"0.0\", \"pop\": \"6\", \"pres\": \"1024\", \"tmp\": &#123; \"max\": \"15\", \"min\": \"7\" &#125;, \"vis\": \"10\", \"wind\": &#123; \"deg\": \"42\", \"dir\": \"东北风\", \"sc\": \"3-4\", \"spd\": \"11\" &#125; &#125;, &#123; \"astro\": &#123; \"sr\": \"06:33\", \"ss\": \"17:23\" &#125;, \"cond\": &#123; \"code_d\": \"100\", \"code_n\": \"100\", \"txt_d\": \"晴\", \"txt_n\": \"晴\" &#125;, \"date\": \"2016-10-23\", \"hum\": \"50\", \"pcpn\": \"0.0\", \"pop\": \"9\", \"pres\": \"1022\", \"tmp\": &#123; \"max\": \"15\", \"min\": \"5\" &#125;, \"vis\": \"10\", \"wind\": &#123; \"deg\": \"184\", \"dir\": \"无持续风向\", \"sc\": \"微风\", \"spd\": \"2\" &#125; &#125;, &#123; \"astro\": &#123; \"sr\": \"06:34\", \"ss\": \"17:22\" &#125;, \"cond\": &#123; \"code_d\": \"104\", \"code_n\": \"100\", \"txt_d\": \"阴\", \"txt_n\": \"晴\" &#125;, \"date\": \"2016-10-24\", \"hum\": \"65\", \"pcpn\": \"6.4\", \"pop\": \"97\", \"pres\": \"1018\", \"tmp\": &#123; \"max\": \"13\", \"min\": \"6\" &#125;, \"vis\": \"9\", \"wind\": &#123; \"deg\": \"175\", \"dir\": \"无持续风向\", \"sc\": \"微风\", \"spd\": \"7\" &#125; &#125;, &#123; \"astro\": &#123; \"sr\": \"06:35\", \"ss\": \"17:21\" &#125;, \"cond\": &#123; \"code_d\": \"100\", \"code_n\": \"101\", \"txt_d\": \"晴\", \"txt_n\": \"多云\" &#125;, \"date\": \"2016-10-25\", \"hum\": \"77\", \"pcpn\": \"0.0\", \"pop\": \"0\", \"pres\": \"1017\", \"tmp\": &#123; \"max\": \"16\", \"min\": \"8\" &#125;, \"vis\": \"10\", \"wind\": &#123; \"deg\": \"178\", \"dir\": \"无持续风向\", \"sc\": \"微风\", \"spd\": \"10\" &#125; &#125;, &#123; \"astro\": &#123; \"sr\": \"06:36\", \"ss\": \"17:19\" &#125;, \"cond\": &#123; \"code_d\": \"101\", \"code_n\": \"104\", \"txt_d\": \"多云\", \"txt_n\": \"阴\" &#125;, \"date\": \"2016-10-26\", \"hum\": \"62\", \"pcpn\": \"0.0\", \"pop\": \"0\", \"pres\": \"1025\", \"tmp\": &#123; \"max\": \"17\", \"min\": \"8\" &#125;, \"vis\": \"10\", \"wind\": &#123; \"deg\": \"139\", \"dir\": \"无持续风向\", \"sc\": \"微风\", \"spd\": \"1\" &#125; &#125;, &#123; \"astro\": &#123; \"sr\": \"06:38\", \"ss\": \"17:18\" &#125;, \"cond\": &#123; \"code_d\": \"104\", \"code_n\": \"100\", \"txt_d\": \"阴\", \"txt_n\": \"晴\" &#125;, \"date\": \"2016-10-27\", \"hum\": \"79\", \"pcpn\": \"5.2\", \"pop\": \"90\", \"pres\": \"1026\", \"tmp\": &#123; \"max\": \"16\", \"min\": \"10\" &#125;, \"vis\": \"9\", \"wind\": &#123; \"deg\": \"146\", \"dir\": \"无持续风向\", \"sc\": \"微风\", \"spd\": \"10\" &#125; &#125;, &#123; \"astro\": &#123; \"sr\": \"06:39\", \"ss\": \"17:17\" &#125;, \"cond\": &#123; \"code_d\": \"100\", \"code_n\": \"100\", \"txt_d\": \"晴\", \"txt_n\": \"晴\" &#125;, \"date\": \"2016-10-28\", \"hum\": \"39\", \"pcpn\": \"0.3\", \"pop\": \"31\", \"pres\": \"1030\", \"tmp\": &#123; \"max\": \"14\", \"min\": \"5\" &#125;, \"vis\": \"10\", \"wind\": &#123; \"deg\": \"347\", \"dir\": \"无持续风向\", \"sc\": \"微风\", \"spd\": \"0\" &#125; &#125; ], \"hourly_forecast\": [ &#123; \"date\": \"2016-10-22 19:00\", \"hum\": \"63\", \"pop\": \"1\", \"pres\": \"1024\", \"tmp\": \"12\", \"wind\": &#123; \"deg\": \"110\", \"dir\": \"东南风\", \"sc\": \"微风\", \"spd\": \"6\" &#125; &#125;, &#123; \"date\": \"2016-10-22 22:00\", \"hum\": \"57\", \"pop\": \"5\", \"pres\": \"1026\", \"tmp\": \"10\", \"wind\": &#123; \"deg\": \"171\", \"dir\": \"南风\", \"sc\": \"微风\", \"spd\": \"8\" &#125; &#125; ], \"now\": &#123; \"cond\": &#123; \"code\": \"101\", \"txt\": \"多云\" &#125;, \"fl\": \"12\", \"hum\": \"52\", \"pcpn\": \"0\", \"pres\": \"1023\", \"tmp\": \"13\", \"vis\": \"10\", \"wind\": &#123; \"deg\": \"40\", \"dir\": \"东北风\", \"sc\": \"4-5\", \"spd\": \"24\" &#125; &#125;, \"status\": \"ok\", \"suggestion\": &#123; \"comf\": &#123; \"brf\": \"较舒适\", \"txt\": \"白天天气晴好，早晚会感觉偏凉，午后舒适、宜人。\" &#125;, \"cw\": &#123; \"brf\": \"较适宜\", \"txt\": \"较适宜洗车，未来一天无雨，风力较小，擦洗一新的汽车至少能保持一天。\" &#125;, \"drsg\": &#123; \"brf\": \"较冷\", \"txt\": \"建议着厚外套加毛衣等服装。年老体弱者宜着大衣、呢外套加羊毛衫。\" &#125;, \"flu\": &#123; \"brf\": \"较易发\", \"txt\": \"天气较凉，较易发生感冒，请适当增加衣服。体质较弱的朋友尤其应该注意防护。\" &#125;, \"sport\": &#123; \"brf\": \"较适宜\", \"txt\": \"天气较好，但风力较大，推荐您进行室内运动，若在户外运动请注意避风保暖。\" &#125;, \"trav\": &#123; \"brf\": \"适宜\", \"txt\": \"天气较好，温度适宜，但风稍微有点大。这样的天气适宜旅游，您可以尽情地享受大自然的无限风光。\" &#125;, \"uv\": &#123; \"brf\": \"弱\", \"txt\": \"紫外线强度较弱，建议出门前涂擦SPF在12-15之间、PA+的防晒护肤品。\" &#125; &#125; &#125; ]&#125; 百度SDK调用API（需下载SDK到你的项目中，SDK网址：http://bbs.apistore.baidu.com/forum.php?mod=viewthread&amp;tid=734&amp;page=1&amp;extra=#pid1229）： 1234567891011121314151617181920212223242526272829303132private void apiTest() &#123; Parameters para = new Parameters(); para.put(\"city\", \"jilin\"); ApiStoreSDK.execute(\"http://apis.baidu.com/heweather/weather/free\", ApiStoreSDK.GET, para, new ApiCallBack() &#123; @Override public void onSuccess(int status, String responseString) &#123; Log.i(\"sdkdemo\", \"onSuccess\"); WeatherUtility.handleWeatherResponse(MainActivity.this, responseString); &#125; @Override public void onComplete() &#123; Log.i(\"sdkdemo\", \"onComplete\"); &#125; @Override public void onError(int status, String responseString, Exception e) &#123; Log.i(\"sdkdemo\", \"onError, status: \" + status); Log.i(\"sdkdemo\", \"errMsg: \" + (e == null ? \"\" : e.getMessage())); &#125; &#125;); showWeather(); &#125; API得到的JSON格式数据responseString传入WeatherUtility中的handleWeatherResponse函数中，使用前面介绍的JSON API对数据进行解析，这里因为只是一个简单Demo所以只对部分数据进行解析： 1234567891011121314151617181920212223242526272829303132public class WeatherUtility&#123; /** * 解析服务器返回的JSON数据，并将解析出的数据储存到本地 */ public static void handleWeatherResponse(Context context,String response)&#123; try &#123; // 首先最外层是&#123;&#125;，创建一个对象 JSONObject jsonObject=new JSONObject(response); //将json对象转换成bean对象。 JSONArray weatherInfo=jsonObject.getJSONArray(\"HeWeather data service 3.0\"); JSONObject weatherInfo1=(JSONObject)weatherInfo.get(0); JSONArray weatherInfo2=weatherInfo1.getJSONArray(\"hourly_forecast\"); JSONObject weatherInfo3=(JSONObject)weatherInfo2.get(0); String text=weatherInfo3.getString(\"pop\"); String temperature=weatherInfo3.getString(\"tmp\"); String time=weatherInfo3.getString(\"date\"); //存入储存文件中。 saveWeatherInfo(context,text,temperature,time); &#125;catch (JSONException e)&#123; e.printStackTrace(); &#125; &#125;public static void saveWeatherInfo(Context context,String text,String temperature,String time)&#123; SharedPreferences.Editor editor= PreferenceManager.getDefaultSharedPreferences(context).edit(); editor.putString(\"text\",text); editor.putString(\"temperature\",temperature); editor.putString(\"time\",time); //提交当前数据 editor.commit();&#125;&#125; 可以看到，我们将数据传递到handleWeatherResponse方法内后，先把数据传入JSONObject类中将JSON对象转换为bean对象，然后使用getJSONArray方法得到”HeWeather data service 3.0”数组对象weatherInfo，再调用get()方法指定返回的数值，这里调用get(0)即调用”HeWeather data service 3.0”数组内的第一个{}，之后的代码和前面如出一辙，最后调用JSONObject类的getXX()方法就可以得到对应传入字符的数据.在本Demo中我们使用轻量级储存类SharedPreferences对数据进行储存，将得到的数据一一存入editor中，取出时直接调用下列代码就OK了 123456private void showWeather() &#123; SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this); temperature.setText(prefs.getString(\"temperature\", \"\")+\"℃\"); weather_state.setText(\"降雨概率：\"+prefs.getString(\"text\", \"\")+\"%\"); time.setText(prefs.getString(\"time\",\"\")); &#125; 本文仅为学习，加深记忆","tags":[{"name":"android开发","slug":"android开发","permalink":"https://popo1379.github.io/tags/android开发/"}]},{"title":"初识微信小程序一，了解小程序基础架构","date":"2016-10-20T05:03:28.000Z","path":"2016/10/20/2016-10-20/","text":"距微信小程序公布已经有一个月的时间了，开发工具也已经放出，尽管内测资格有限，但我们依旧可以通过微信小程序开发工具看到微信小程序大体的模样，本文从一个初学者角度，对微信小程序的基础架构进行探究学习。开发工具创建新项目: 因为没有内测码，只能选择无APPID模式进入工具内调试，没办法真机测试，所以只能先纸上谈兵咯开发工具调试界面就长这样，目前小程序开发者工具已经更新到0.10版本，从更新速度看腾讯还是很重视小程序的。小程序的架构：这是一个大牛做出来的小程序Demo代码架构，腾讯管这种叫MINA架构，可以看到，其中包含了几个文件夹和三个app开头的代码文件，分别是app.js app.jsonapp.wxss,不出意料，这就是小程序代码的核心，小程序在运行过程中将读取这三个文件，生成小程序app。这是大牛刘智聪做得架构图，这里直接引用了。根据资料，我们可以简单的了解这三个文件功能，方便日后开发小程序做参考； app.js为小程序的脚本代码，负责为小程序监听处理生命周期，声明全局变量，调用小程序框架提供的API。 app.json为小程序提供全局配置，包括设置页面组成，窗口配色，标题等。 app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。在前面的代码框架中，我们还发现三个文件夹，Images，pages以及utils。Images负责存放APP中所需要的图片资源。utils是放通用工具类方法的一个文件夹，下面我们来详细了解pages这个文件夹查看该文件夹后，我们可以看到该文件夹负责存放所有页面可以看到，在这个Demo中共有五个页面，这五个页面都包含在pages文件夹内，每个页面的路径和页面名都需要写在app.json页面的pages类 12345678910111213141516171819202122232425262728293031323334353637383940\"pages\":[\"pages/message/message\",\"pages/contact/contact\",\"pages/dynamic/dynamic\",\"pages/dynamic/music/music\",\"pages/index/index\",\"pages/logs/logs\"], \"window\":&#123;\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#12b7f4\",\"navigationBarTitleText\": \"WeChatForQQ\",\"navigationBarTextStyle\":\"white\",\"backgroundColor\": \"#fbf9fe\"&#125;,\"tabBar\": &#123;\"color\": \"#9B9DB1\",\"selectedColor\": \"#3cc51f\",\"borderStyle\": \"black\",\"backgroundColor\": \"#ffffff\",\"list\": [&#123;\"pagePath\": \"pages/message/message\",\"iconPath\": \"images/tab_message_normal.png\",\"selectedIconPath\": \"images/tab_message_selected.png\", \"text\": \"消息\"&#125;, &#123; \"pagePath\": \"pages/contact/contact\",\"iconPath\": \"images/tab_contact_normal.png\",\"selectedIconPath\": \"images/tab_contact_selected.png\",\"text\": \"联系人\"&#125;,&#123;\"pagePath\": \"pages/dynamic/dynamic\",\"iconPath\": \"images/tab_dynamic_normal.png\",\"selectedIconPath\": \"images/tab_dynamic_selected.png\",\"text\": \"动态\"&#125;]&#125;&#125; 每个页面下都有四个文件，以index为例，这四个文件分别是index.js、index.wxml、index.wxss、index.json 123456789101112131415161718192021222324252627//index.js//获取应用实例var app = getApp()Page(&#123; data: &#123; motto: 'Hello World', userInfo: &#123;&#125; &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;) &#125;, onLoad: function () &#123; console.log('onLoad') var that = this //调用应用实例的方法获取全局数据 app.getUserInfo(function(userInfo)&#123; //更新数据 that.setData(&#123; userInfo:userInfo &#125;) &#125;) &#125;&#125;) index.js是页面的脚本文件，在这个文件中我们可以监听处理该页面的生命周期，声明变量，监听事件等。index.json为该页面提供配置，注意，该文件是非必要的，如果没有在指定该文件，小程序将直接使用app.json中的默认配置。index.wxss为页面提供样式表，和json一样，没有指定该文件时小程序默认app.wxss为该页面的样式表。 123456789101112131415161718.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125;.userinfo-avatar &#123; width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%;&#125;.userinfo-nickname &#123; color: #aaa;&#125;.usermotto &#123; margin-top: 200px;&#125; 本文仅以学习为目的，写的很浅，有很多地方不到位，感谢围观。","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://popo1379.github.io/tags/微信小程序/"}]},{"title":"Hello World","date":"2016-10-19T03:35:28.000Z","path":"2016/10/19/hello-world/","text":"在学长极力推荐下，经过一天一夜的折腾，终于有了自己的一个小博客。 尽管许多功能还没有搞懂，但是依然兴奋，甚至彻夜难眠，这是属于我自己的一块小天地，真正由我搭建起来的小站。 这种感觉就和小时候第一次用积木搭建小房子的感觉一样满足 甚至让我有了一种归宿感，我想把我的生活上的点点滴滴，技术上学习到的一切都搬到这里，把我在这世上的一切， 都通过一个个字符寄存在这里，这里将成为我永远的乌托邦。 我是这的主人，我是popo1379.","tags":[{"name":"新世界","slug":"新世界","permalink":"https://popo1379.github.io/tags/新世界/"}]}]